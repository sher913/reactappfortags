{"ast":null,"code":"/*! ColReorder 1.5.4\n * Â©2010-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     1.5.4\n * @file        dataTables.colReorder.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2010-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n  /**\n   * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n   * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n   *  @method  fnInvertKeyValues\n   *  @param   array aIn Array to switch around\n   *  @returns array\n   */\n\n  function fnInvertKeyValues(aIn) {\n    var aRet = [];\n\n    for (var i = 0, iLen = aIn.length; i < iLen; i++) {\n      aRet[aIn[i]] = i;\n    }\n\n    return aRet;\n  }\n  /**\n   * Modify an array by switching the position of two elements\n   *  @method  fnArraySwitch\n   *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)\n   *  @param   int iFrom From point\n   *  @param   int iTo Insert point\n   *  @returns void\n   */\n\n\n  function fnArraySwitch(aArray, iFrom, iTo) {\n    var mStore = aArray.splice(iFrom, 1)[0];\n    aArray.splice(iTo, 0, mStore);\n  }\n  /**\n   * Switch the positions of nodes in a parent node (note this is specifically designed for\n   * table rows). Note this function considers all element nodes under the parent!\n   *  @method  fnDomSwitch\n   *  @param   string sTag Tag to consider\n   *  @param   int iFrom Element to move\n   *  @param   int Point to element the element to (before this point), can be null for append\n   *  @returns void\n   */\n\n\n  function fnDomSwitch(nParent, iFrom, iTo) {\n    var anTags = [];\n\n    for (var i = 0, iLen = nParent.childNodes.length; i < iLen; i++) {\n      if (nParent.childNodes[i].nodeType == 1) {\n        anTags.push(nParent.childNodes[i]);\n      }\n    }\n\n    var nStore = anTags[iFrom];\n\n    if (iTo !== null) {\n      nParent.insertBefore(nStore, anTags[iTo]);\n    } else {\n      nParent.appendChild(nStore);\n    }\n  }\n  /**\n   * Plug-in for DataTables which will reorder the internal column structure by taking the column\n   * from one position (iFrom) and insert it into a given point (iTo).\n   *  @method  $.fn.dataTableExt.oApi.fnColReorder\n   *  @param   object oSettings DataTables settings object - automatically added by DataTables!\n   *  @param   int iFrom Take the column to be repositioned from this point\n   *  @param   int iTo and insert it into this point\n   *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)\n   *    not a live reorder\n   *  @param   bool invalidateRows speeds up processing if false passed\n   *  @returns void\n   */\n\n\n  $.fn.dataTableExt.oApi.fnColReorder = function (oSettings, iFrom, iTo, drop, invalidateRows) {\n    var i,\n        iLen,\n        j,\n        jLen,\n        jen,\n        iCols = oSettings.aoColumns.length,\n        nTrs,\n        oCol;\n\n    var attrMap = function (obj, prop, mapping) {\n      if (!obj[prop] || typeof obj[prop] === 'function') {\n        return;\n      }\n\n      var a = obj[prop].split('.');\n      var num = a.shift();\n\n      if (isNaN(num * 1)) {\n        return;\n      }\n\n      obj[prop] = mapping[num * 1] + '.' + a.join('.');\n    };\n    /* Sanity check in the input */\n\n\n    if (iFrom == iTo) {\n      /* Pointless reorder */\n      return;\n    }\n\n    if (iFrom < 0 || iFrom >= iCols) {\n      this.oApi._fnLog(oSettings, 1, \"ColReorder 'from' index is out of bounds: \" + iFrom);\n\n      return;\n    }\n\n    if (iTo < 0 || iTo >= iCols) {\n      this.oApi._fnLog(oSettings, 1, \"ColReorder 'to' index is out of bounds: \" + iTo);\n\n      return;\n    }\n    /*\n     * Calculate the new column array index, so we have a mapping between the old and new\n     */\n\n\n    var aiMapping = [];\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      aiMapping[i] = i;\n    }\n\n    fnArraySwitch(aiMapping, iFrom, iTo);\n    var aiInvertMapping = fnInvertKeyValues(aiMapping);\n    /*\n     * Convert all internal indexing to the new column order indexes\n     */\n\n    /* Sorting */\n\n    for (i = 0, iLen = oSettings.aaSorting.length; i < iLen; i++) {\n      oSettings.aaSorting[i][0] = aiInvertMapping[oSettings.aaSorting[i][0]];\n    }\n    /* Fixed sorting */\n\n\n    if (oSettings.aaSortingFixed !== null) {\n      for (i = 0, iLen = oSettings.aaSortingFixed.length; i < iLen; i++) {\n        oSettings.aaSortingFixed[i][0] = aiInvertMapping[oSettings.aaSortingFixed[i][0]];\n      }\n    }\n    /* Data column sorting (the column which the sort for a given column should take place on) */\n\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      oCol = oSettings.aoColumns[i];\n\n      for (j = 0, jLen = oCol.aDataSort.length; j < jLen; j++) {\n        oCol.aDataSort[j] = aiInvertMapping[oCol.aDataSort[j]];\n      } // Update the column indexes\n\n\n      oCol.idx = aiInvertMapping[oCol.idx];\n    } // Update 1.10 optimised sort class removal variable\n\n\n    $.each(oSettings.aLastSort, function (i, val) {\n      oSettings.aLastSort[i].src = aiInvertMapping[val.src];\n    });\n    /* Update the Get and Set functions for each column */\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      oCol = oSettings.aoColumns[i];\n\n      if (typeof oCol.mData == 'number') {\n        oCol.mData = aiInvertMapping[oCol.mData];\n      } else if ($.isPlainObject(oCol.mData)) {\n        // HTML5 data sourced\n        attrMap(oCol.mData, '_', aiInvertMapping);\n        attrMap(oCol.mData, 'filter', aiInvertMapping);\n        attrMap(oCol.mData, 'sort', aiInvertMapping);\n        attrMap(oCol.mData, 'type', aiInvertMapping);\n      }\n    }\n    /*\n     * Move the DOM elements\n     */\n\n\n    if (oSettings.aoColumns[iFrom].bVisible) {\n      /* Calculate the current visible index and the point to insert the node before. The insert\n       * before needs to take into account that there might not be an element to insert before,\n       * in which case it will be null, and an appendChild should be used\n       */\n      var iVisibleIndex = this.oApi._fnColumnIndexToVisible(oSettings, iFrom);\n\n      var iInsertBeforeIndex = null;\n      i = iTo < iFrom ? iTo : iTo + 1;\n\n      while (iInsertBeforeIndex === null && i < iCols) {\n        iInsertBeforeIndex = this.oApi._fnColumnIndexToVisible(oSettings, i);\n        i++;\n      }\n      /* Header */\n\n\n      nTrs = oSettings.nTHead.getElementsByTagName('tr');\n\n      for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n        fnDomSwitch(nTrs[i], iVisibleIndex, iInsertBeforeIndex);\n      }\n      /* Footer */\n\n\n      if (oSettings.nTFoot !== null) {\n        nTrs = oSettings.nTFoot.getElementsByTagName('tr');\n\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n          fnDomSwitch(nTrs[i], iVisibleIndex, iInsertBeforeIndex);\n        }\n      }\n      /* Body */\n\n\n      for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {\n        if (oSettings.aoData[i].nTr !== null) {\n          fnDomSwitch(oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex);\n        }\n      }\n    }\n    /*\n     * Move the internal array elements\n     */\n\n    /* Columns */\n\n\n    fnArraySwitch(oSettings.aoColumns, iFrom, iTo); // regenerate the get / set functions\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      oSettings.oApi._fnColumnOptions(oSettings, i, {});\n    }\n    /* Search columns */\n\n\n    fnArraySwitch(oSettings.aoPreSearchCols, iFrom, iTo);\n    /* Array array - internal data anodes cache */\n\n    for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {\n      var data = oSettings.aoData[i];\n      var cells = data.anCells;\n\n      if (cells) {\n        fnArraySwitch(cells, iFrom, iTo); // Longer term, should this be moved into the DataTables' invalidate\n        // methods?\n\n        for (j = 0, jen = cells.length; j < jen; j++) {\n          if (cells[j] && cells[j]._DT_CellIndex) {\n            cells[j]._DT_CellIndex.column = j;\n          }\n        }\n      } // For DOM sourced data, the invalidate will reread the cell into\n      // the data array, but for data sources as an array, they need to\n      // be flipped\n\n\n      if (data.src !== 'dom' && Array.isArray(data._aData)) {\n        fnArraySwitch(data._aData, iFrom, iTo);\n      }\n    }\n    /* Reposition the header elements in the header layout array */\n\n\n    for (i = 0, iLen = oSettings.aoHeader.length; i < iLen; i++) {\n      fnArraySwitch(oSettings.aoHeader[i], iFrom, iTo);\n    }\n\n    if (oSettings.aoFooter !== null) {\n      for (i = 0, iLen = oSettings.aoFooter.length; i < iLen; i++) {\n        fnArraySwitch(oSettings.aoFooter[i], iFrom, iTo);\n      }\n    }\n\n    if (invalidateRows || invalidateRows === undefined) {\n      $.fn.dataTable.Api(oSettings).rows().invalidate();\n    }\n    /*\n     * Update DataTables' event handlers\n     */\n\n    /* Sort listener */\n\n\n    for (i = 0, iLen = iCols; i < iLen; i++) {\n      $(oSettings.aoColumns[i].nTh).off('.DT');\n\n      this.oApi._fnSortAttachListener(oSettings, oSettings.aoColumns[i].nTh, i);\n    }\n    /* Fire an event so other plug-ins can update */\n\n\n    $(oSettings.oInstance).trigger('column-reorder.dt', [oSettings, {\n      from: iFrom,\n      to: iTo,\n      mapping: aiInvertMapping,\n      drop: drop,\n      // Old style parameters for compatibility\n      iFrom: iFrom,\n      iTo: iTo,\n      aiInvertMapping: aiInvertMapping\n    }]);\n  };\n  /**\n   * ColReorder provides column visibility control for DataTables\n   * @class ColReorder\n   * @constructor\n   * @param {object} dt DataTables settings object\n   * @param {object} opts ColReorder options\n   */\n\n\n  var ColReorder = function (dt, opts) {\n    var settings = new $.fn.dataTable.Api(dt).settings()[0]; // Ensure that we can't initialise on the same table twice\n\n    if (settings._colReorder) {\n      return settings._colReorder;\n    } // Allow the options to be a boolean for defaults\n\n\n    if (opts === true) {\n      opts = {};\n    } // Convert from camelCase to Hungarian, just as DataTables does\n\n\n    var camelToHungarian = $.fn.dataTable.camelToHungarian;\n\n    if (camelToHungarian) {\n      camelToHungarian(ColReorder.defaults, ColReorder.defaults, true);\n      camelToHungarian(ColReorder.defaults, opts || {});\n    }\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public class variables\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * @namespace Settings object which contains customisable information for ColReorder instance\n     */\n\n\n    this.s = {\n      /**\n       * DataTables settings object\n       *  @property dt\n       *  @type     Object\n       *  @default  null\n       */\n      \"dt\": null,\n\n      /**\n       * Enable flag\n       *  @property dt\n       *  @type     Object\n       *  @default  null\n       */\n      \"enable\": null,\n\n      /**\n       * Initialisation object used for this instance\n       *  @property init\n       *  @type     object\n       *  @default  {}\n       */\n      \"init\": $.extend(true, {}, ColReorder.defaults, opts),\n\n      /**\n       * Number of columns to fix (not allow to be reordered)\n       *  @property fixed\n       *  @type     int\n       *  @default  0\n       */\n      \"fixed\": 0,\n\n      /**\n       * Number of columns to fix counting from right (not allow to be reordered)\n       *  @property fixedRight\n       *  @type     int\n       *  @default  0\n       */\n      \"fixedRight\": 0,\n\n      /**\n       * Callback function for once the reorder has been done\n       *  @property reorderCallback\n       *  @type     function\n       *  @default  null\n       */\n      \"reorderCallback\": null,\n\n      /**\n       * @namespace Information used for the mouse drag\n       */\n      \"mouse\": {\n        \"startX\": -1,\n        \"startY\": -1,\n        \"offsetX\": -1,\n        \"offsetY\": -1,\n        \"target\": -1,\n        \"targetIndex\": -1,\n        \"fromIndex\": -1\n      },\n\n      /**\n       * Information which is used for positioning the insert cusor and knowing where to do the\n       * insert. Array of objects with the properties:\n       *   x: x-axis position\n       *   to: insert point\n       *  @property aoTargets\n       *  @type     array\n       *  @default  []\n       */\n      \"aoTargets\": []\n    };\n    /**\n     * @namespace Common and useful DOM elements for the class instance\n     */\n\n    this.dom = {\n      /**\n       * Dragging element (the one the mouse is moving)\n       *  @property drag\n       *  @type     element\n       *  @default  null\n       */\n      \"drag\": null,\n\n      /**\n       * The insert cursor\n       *  @property pointer\n       *  @type     element\n       *  @default  null\n       */\n      \"pointer\": null\n    };\n    /* Constructor logic */\n\n    this.s.enable = this.s.init.bEnable;\n    this.s.dt = settings;\n    this.s.dt._colReorder = this;\n\n    this._fnConstruct();\n\n    return this;\n  };\n\n  $.extend(ColReorder.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public methods\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Enable / disable end user interaction\n     */\n    fnEnable: function (flag) {\n      if (flag === false) {\n        return fnDisable();\n      }\n\n      this.s.enable = true;\n    },\n\n    /**\n     * Disable end user interaction\n     */\n    fnDisable: function () {\n      this.s.enable = false;\n    },\n\n    /**\n     * Reset the column ordering to the original ordering that was detected on\n     * start up.\n     *  @return {this} Returns `this` for chaining.\n     *\n     *  @example\n     *    // DataTables initialisation with ColReorder\n     *    var table = $('#example').dataTable( {\n     *        \"sDom\": 'Rlfrtip'\n     *    } );\n     *\n     *    // Add click event to a button to reset the ordering\n     *    $('#resetOrdering').click( function (e) {\n     *        e.preventDefault();\n     *        $.fn.dataTable.ColReorder( table ).fnReset();\n     *    } );\n     */\n    \"fnReset\": function () {\n      this._fnOrderColumns(this.fnOrder());\n\n      return this;\n    },\n\n    /**\n     * `Deprecated` - Get the current order of the columns, as an array.\n     *  @return {array} Array of column identifiers\n     *  @deprecated `fnOrder` should be used in preference to this method.\n     *      `fnOrder` acts as a getter/setter.\n     */\n    \"fnGetCurrentOrder\": function () {\n      return this.fnOrder();\n    },\n\n    /**\n     * Get the current order of the columns, as an array. Note that the values\n     * given in the array are unique identifiers for each column. Currently\n     * these are the original ordering of the columns that was detected on\n     * start up, but this could potentially change in future.\n     *  @return {array} Array of column identifiers\n     *\n     *  @example\n     *    // Get column ordering for the table\n     *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();\n     */\n\n    /**\n    * Set the order of the columns, from the positions identified in the\n    * ordering array given. Note that ColReorder takes a brute force approach\n    * to reordering, so it is possible multiple reordering events will occur\n    * before the final order is settled upon.\n    *  @param {array} [set] Array of column identifiers in the new order. Note\n    *    that every column must be included, uniquely, in this array.\n    *  @return {this} Returns `this` for chaining.\n    *\n    *  @example\n    *    // Swap the first and second columns\n    *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );\n    *\n    *  @example\n    *    // Move the first column to the end for the table `#example`\n    *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();\n    *    var first = curr.shift();\n    *    curr.push( first );\n    *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );\n    *\n    *  @example\n    *    // Reverse the table's order\n    *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(\n    *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()\n    *    );\n    */\n    \"fnOrder\": function (set, original) {\n      var a = [],\n          i,\n          ien,\n          j,\n          jen;\n      var columns = this.s.dt.aoColumns;\n\n      if (set === undefined) {\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          a.push(columns[i]._ColReorder_iOrigCol);\n        }\n\n        return a;\n      } // The order given is based on the original indexes, rather than the\n      // existing ones, so we need to translate from the original to current\n      // before then doing the order\n\n\n      if (original) {\n        var order = this.fnOrder();\n\n        for (i = 0, ien = set.length; i < ien; i++) {\n          a.push($.inArray(set[i], order));\n        }\n\n        set = a;\n      }\n\n      this._fnOrderColumns(fnInvertKeyValues(set));\n\n      return this;\n    },\n\n    /**\n     * Convert from the original column index, to the original\n     *\n     * @param  {int|array} idx Index(es) to convert\n     * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`\n     *   or `'toOriginal` / `fromCurrent`\n     * @return {int|array}     Converted values\n     */\n    fnTranspose: function (idx, dir) {\n      if (!dir) {\n        dir = 'toCurrent';\n      }\n\n      var order = this.fnOrder();\n      var columns = this.s.dt.aoColumns;\n\n      if (dir === 'toCurrent') {\n        // Given an original index, want the current\n        return !Array.isArray(idx) ? $.inArray(idx, order) : $.map(idx, function (index) {\n          return $.inArray(index, order);\n        });\n      } else {\n        // Given a current index, want the original\n        return !Array.isArray(idx) ? columns[idx]._ColReorder_iOrigCol : $.map(idx, function (index) {\n          return columns[index]._ColReorder_iOrigCol;\n        });\n      }\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods (they are of course public in JS, but recommended as private)\n     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Constructor logic\n     *  @method  _fnConstruct\n     *  @returns void\n     *  @private\n     */\n    \"_fnConstruct\": function () {\n      var that = this;\n      var iLen = this.s.dt.aoColumns.length;\n      var table = this.s.dt.nTable;\n      var i;\n      /* Columns discounted from reordering - counting left to right */\n\n      if (this.s.init.iFixedColumns) {\n        this.s.fixed = this.s.init.iFixedColumns;\n      }\n\n      if (this.s.init.iFixedColumnsLeft) {\n        this.s.fixed = this.s.init.iFixedColumnsLeft;\n      }\n      /* Columns discounted from reordering - counting right to left */\n\n\n      this.s.fixedRight = this.s.init.iFixedColumnsRight ? this.s.init.iFixedColumnsRight : 0;\n      /* Drop callback initialisation option */\n\n      if (this.s.init.fnReorderCallback) {\n        this.s.reorderCallback = this.s.init.fnReorderCallback;\n      }\n      /* Add event handlers for the drag and drop, and also mark the original column order */\n\n\n      for (i = 0; i < iLen; i++) {\n        if (i > this.s.fixed - 1 && i < iLen - this.s.fixedRight) {\n          this._fnMouseListener(i, this.s.dt.aoColumns[i].nTh);\n        }\n        /* Mark the original column order for later reference */\n\n\n        this.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;\n      }\n      /* State saving */\n\n\n      this.s.dt.oApi._fnCallbackReg(this.s.dt, 'aoStateSaveParams', function (oS, oData) {\n        that._fnStateSave.call(that, oData);\n      }, \"ColReorder_State\");\n      /* An initial column order has been specified */\n\n\n      var aiOrder = null;\n\n      if (this.s.init.aiOrder) {\n        aiOrder = this.s.init.aiOrder.slice();\n      }\n      /* State loading, overrides the column order given */\n\n\n      if (this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' && this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length) {\n        aiOrder = this.s.dt.oLoadedState.ColReorder;\n      }\n      /* If we have an order to apply - do so */\n\n\n      if (aiOrder) {\n        /* We might be called during or after the DataTables initialisation. If before, then we need\n         * to wait until the draw is done, if after, then do what we need to do right away\n         */\n        if (!that.s.dt._bInitComplete) {\n          var bDone = false;\n          $(table).on('draw.dt.colReorder', function () {\n            if (!that.s.dt._bInitComplete && !bDone) {\n              bDone = true;\n              var resort = fnInvertKeyValues(aiOrder);\n\n              that._fnOrderColumns.call(that, resort);\n            }\n          });\n        } else {\n          var resort = fnInvertKeyValues(aiOrder);\n\n          that._fnOrderColumns.call(that, resort);\n        }\n      } else {\n        this._fnSetColumnIndexes();\n      } // Destroy clean up\n\n\n      $(table).on('destroy.dt.colReorder', function () {\n        $(table).off('destroy.dt.colReorder draw.dt.colReorder');\n        $.each(that.s.dt.aoColumns, function (i, column) {\n          $(column.nTh).off('.ColReorder');\n          $(column.nTh).removeAttr('data-column-index');\n        });\n        that.s.dt._colReorder = null;\n        that.s = null;\n      });\n    },\n\n    /**\n     * Set the column order from an array\n     *  @method  _fnOrderColumns\n     *  @param   array a An array of integers which dictate the column order that should be applied\n     *  @returns void\n     *  @private\n     */\n    \"_fnOrderColumns\": function (a) {\n      var changed = false;\n\n      if (a.length != this.s.dt.aoColumns.length) {\n        this.s.dt.oInstance.oApi._fnLog(this.s.dt, 1, \"ColReorder - array reorder does not \" + \"match known number of columns. Skipping.\");\n\n        return;\n      }\n\n      for (var i = 0, iLen = a.length; i < iLen; i++) {\n        var currIndex = $.inArray(i, a);\n\n        if (i != currIndex) {\n          /* Reorder our switching array */\n          fnArraySwitch(a, currIndex, i);\n          /* Do the column reorder in the table */\n\n          this.s.dt.oInstance.fnColReorder(currIndex, i, true, false);\n          changed = true;\n        }\n      }\n\n      this._fnSetColumnIndexes(); // Has anything actually changed? If not, then nothing else to do\n\n\n      if (!changed) {\n        return;\n      }\n\n      $.fn.dataTable.Api(this.s.dt).rows().invalidate();\n      /* When scrolling we need to recalculate the column sizes to allow for the shift */\n\n      if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n        this.s.dt.oInstance.fnAdjustColumnSizing(false);\n      }\n      /* Save the state */\n\n\n      this.s.dt.oInstance.oApi._fnSaveState(this.s.dt);\n\n      if (this.s.reorderCallback !== null) {\n        this.s.reorderCallback.call(this);\n      }\n    },\n\n    /**\n     * Because we change the indexes of columns in the table, relative to their starting point\n     * we need to reorder the state columns to what they are at the starting point so we can\n     * then rearrange them again on state load!\n     *  @method  _fnStateSave\n     *  @param   object oState DataTables state\n     *  @returns string JSON encoded cookie string for DataTables\n     *  @private\n     */\n    \"_fnStateSave\": function (oState) {\n      var i, iLen, aCopy, iOrigColumn;\n      var oSettings = this.s.dt;\n      var columns = oSettings.aoColumns;\n      oState.ColReorder = [];\n      /* Sorting */\n\n      if (oState.aaSorting) {\n        // 1.10.0-\n        for (i = 0; i < oState.aaSorting.length; i++) {\n          oState.aaSorting[i][0] = columns[oState.aaSorting[i][0]]._ColReorder_iOrigCol;\n        }\n\n        var aSearchCopy = $.extend(true, [], oState.aoSearchCols);\n\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\n          iOrigColumn = columns[i]._ColReorder_iOrigCol;\n          /* Column filter */\n\n          oState.aoSearchCols[iOrigColumn] = aSearchCopy[i];\n          /* Visibility */\n\n          oState.abVisCols[iOrigColumn] = columns[i].bVisible;\n          /* Column reordering */\n\n          oState.ColReorder.push(iOrigColumn);\n        }\n      } else if (oState.order) {\n        // 1.10.1+\n        for (i = 0; i < oState.order.length; i++) {\n          oState.order[i][0] = columns[oState.order[i][0]]._ColReorder_iOrigCol;\n        }\n\n        var stateColumnsCopy = $.extend(true, [], oState.columns);\n\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\n          iOrigColumn = columns[i]._ColReorder_iOrigCol;\n          /* Columns */\n\n          oState.columns[iOrigColumn] = stateColumnsCopy[i];\n          /* Column reordering */\n\n          oState.ColReorder.push(iOrigColumn);\n        }\n      }\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Mouse drop and drag\n     */\n\n    /**\n     * Add a mouse down listener to a particluar TH element\n     *  @method  _fnMouseListener\n     *  @param   int i Column index\n     *  @param   element nTh TH element clicked on\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseListener\": function (i, nTh) {\n      var that = this;\n      $(nTh).on('mousedown.ColReorder', function (e) {\n        if (that.s.enable && e.which === 1) {\n          that._fnMouseDown.call(that, e, nTh);\n        }\n      }).on('touchstart.ColReorder', function (e) {\n        if (that.s.enable) {\n          that._fnMouseDown.call(that, e, nTh);\n        }\n      });\n    },\n\n    /**\n     * Mouse down on a TH element in the table header\n     *  @method  _fnMouseDown\n     *  @param   event e Mouse event\n     *  @param   element nTh TH element to be dragged\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseDown\": function (e, nTh) {\n      var that = this;\n      /* Store information about the mouse position */\n\n      var target = $(e.target).closest('th, td');\n      var offset = target.offset();\n      var idx = parseInt($(nTh).attr('data-column-index'), 10);\n\n      if (idx === undefined) {\n        return;\n      }\n\n      this.s.mouse.startX = this._fnCursorPosition(e, 'pageX');\n      this.s.mouse.startY = this._fnCursorPosition(e, 'pageY');\n      this.s.mouse.offsetX = this._fnCursorPosition(e, 'pageX') - offset.left;\n      this.s.mouse.offsetY = this._fnCursorPosition(e, 'pageY') - offset.top;\n      this.s.mouse.target = this.s.dt.aoColumns[idx].nTh; //target[0];\n\n      this.s.mouse.targetIndex = idx;\n      this.s.mouse.fromIndex = idx;\n\n      this._fnRegions();\n      /* Add event handlers to the document */\n\n\n      $(document).on('mousemove.ColReorder touchmove.ColReorder', function (e) {\n        that._fnMouseMove.call(that, e);\n      }).on('mouseup.ColReorder touchend.ColReorder', function (e) {\n        that._fnMouseUp.call(that, e);\n      });\n    },\n\n    /**\n     * Deal with a mouse move event while dragging a node\n     *  @method  _fnMouseMove\n     *  @param   event e Mouse event\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseMove\": function (e) {\n      var that = this;\n\n      if (this.dom.drag === null) {\n        /* Only create the drag element if the mouse has moved a specific distance from the start\n         * point - this allows the user to make small mouse movements when sorting and not have a\n         * possibly confusing drag element showing up\n         */\n        if (Math.pow(Math.pow(this._fnCursorPosition(e, 'pageX') - this.s.mouse.startX, 2) + Math.pow(this._fnCursorPosition(e, 'pageY') - this.s.mouse.startY, 2), 0.5) < 5) {\n          return;\n        }\n\n        this._fnCreateDragNode();\n      }\n      /* Position the element - we respect where in the element the click occured */\n\n\n      this.dom.drag.css({\n        left: this._fnCursorPosition(e, 'pageX') - this.s.mouse.offsetX,\n        top: this._fnCursorPosition(e, 'pageY') - this.s.mouse.offsetY\n      });\n      /* Based on the current mouse position, calculate where the insert should go */\n\n      var target;\n      var lastToIndex = this.s.mouse.toIndex;\n\n      var cursorXPosiotion = this._fnCursorPosition(e, 'pageX');\n\n      var targetsPrev = function (i) {\n        while (i >= 0) {\n          i--;\n\n          if (i <= 0) {\n            return null;\n          }\n\n          if (that.s.aoTargets[i + 1].x !== that.s.aoTargets[i].x) {\n            return that.s.aoTargets[i];\n          }\n        }\n      };\n\n      var firstNotHidden = function () {\n        for (var i = 0; i < that.s.aoTargets.length - 1; i++) {\n          if (that.s.aoTargets[i].x !== that.s.aoTargets[i + 1].x) {\n            return that.s.aoTargets[i];\n          }\n        }\n      };\n\n      var lastNotHidden = function () {\n        for (var i = that.s.aoTargets.length - 1; i > 0; i--) {\n          if (that.s.aoTargets[i].x !== that.s.aoTargets[i - 1].x) {\n            return that.s.aoTargets[i];\n          }\n        }\n      };\n\n      for (var i = 1; i < this.s.aoTargets.length; i++) {\n        var prevTarget = targetsPrev(i);\n\n        if (!prevTarget) {\n          prevTarget = firstNotHidden();\n        }\n\n        var prevTargetMiddle = prevTarget.x + (this.s.aoTargets[i].x - prevTarget.x) / 2;\n\n        if (this._fnIsLtr()) {\n          if (cursorXPosiotion < prevTargetMiddle) {\n            target = prevTarget;\n            break;\n          }\n        } else {\n          if (cursorXPosiotion > prevTargetMiddle) {\n            target = prevTarget;\n            break;\n          }\n        }\n      }\n\n      if (target) {\n        this.dom.pointer.css('left', target.x);\n        this.s.mouse.toIndex = target.to;\n      } else {\n        // The insert element wasn't positioned in the array (less than\n        // operator), so we put it at the end\n        this.dom.pointer.css('left', lastNotHidden().x);\n        this.s.mouse.toIndex = lastNotHidden().to;\n      } // Perform reordering if realtime updating is on and the column has moved\n\n\n      if (this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex) {\n        this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex);\n        this.s.mouse.fromIndex = this.s.mouse.toIndex; // Not great for performance, but required to keep everything in alignment\n\n        if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n          this.s.dt.oInstance.fnAdjustColumnSizing(false);\n        }\n\n        this._fnRegions();\n      }\n    },\n\n    /**\n     * Finish off the mouse drag and insert the column where needed\n     *  @method  _fnMouseUp\n     *  @param   event e Mouse event\n     *  @returns void\n     *  @private\n     */\n    \"_fnMouseUp\": function (e) {\n      var that = this;\n      $(document).off('.ColReorder');\n\n      if (this.dom.drag !== null) {\n        /* Remove the guide elements */\n        this.dom.drag.remove();\n        this.dom.pointer.remove();\n        this.dom.drag = null;\n        this.dom.pointer = null;\n        /* Actually do the reorder */\n\n        this.s.dt.oInstance.fnColReorder(this.s.mouse.fromIndex, this.s.mouse.toIndex, true);\n\n        this._fnSetColumnIndexes();\n        /* When scrolling we need to recalculate the column sizes to allow for the shift */\n\n\n        if (this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\") {\n          this.s.dt.oInstance.fnAdjustColumnSizing(false);\n        }\n        /* Save the state */\n\n\n        this.s.dt.oInstance.oApi._fnSaveState(this.s.dt);\n\n        if (this.s.reorderCallback !== null) {\n          this.s.reorderCallback.call(this);\n        }\n      }\n    },\n\n    /**\n     * Calculate a cached array with the points of the column inserts, and the\n     * 'to' points\n     *  @method  _fnRegions\n     *  @returns void\n     *  @private\n     */\n    \"_fnRegions\": function () {\n      var aoColumns = this.s.dt.aoColumns;\n\n      var isLTR = this._fnIsLtr();\n\n      this.s.aoTargets.splice(0, this.s.aoTargets.length);\n      var lastBound = $(this.s.dt.nTable).offset().left;\n      var aoColumnBounds = [];\n      $.each(aoColumns, function (i, column) {\n        if (column.bVisible && column.nTh.style.display !== 'none') {\n          var nth = $(column.nTh);\n          var bound = nth.offset().left;\n\n          if (isLTR) {\n            bound += nth.outerWidth();\n          }\n\n          aoColumnBounds.push({\n            index: i,\n            bound: bound\n          });\n          lastBound = bound;\n        } else {\n          aoColumnBounds.push({\n            index: i,\n            bound: lastBound\n          });\n        }\n      });\n      var firstColumn = aoColumnBounds[0];\n      var firstColumnWidth = $(aoColumns[firstColumn.index].nTh).outerWidth();\n      this.s.aoTargets.push({\n        to: 0,\n        x: firstColumn.bound - firstColumnWidth\n      });\n\n      for (var i = 0; i < aoColumnBounds.length; i++) {\n        var columnBound = aoColumnBounds[i];\n        var iToPoint = columnBound.index;\n        /* For the column / header in question, we want it's position to remain the same if the\n        * position is just to it's immediate left or right, so we only increment the counter for\n        * other columns\n        */\n\n        if (columnBound.index < this.s.mouse.fromIndex) {\n          iToPoint++;\n        }\n\n        this.s.aoTargets.push({\n          to: iToPoint,\n          x: columnBound.bound\n        });\n      }\n      /* Disallow columns for being reordered by drag and drop, counting right to left */\n\n\n      if (this.s.fixedRight !== 0) {\n        this.s.aoTargets.splice(this.s.aoTargets.length - this.s.fixedRight);\n      }\n      /* Disallow columns for being reordered by drag and drop, counting left to right */\n\n\n      if (this.s.fixed !== 0) {\n        this.s.aoTargets.splice(0, this.s.fixed);\n      }\n    },\n\n    /**\n     * Copy the TH element that is being drags so the user has the idea that they are actually\n     * moving it around the page.\n     *  @method  _fnCreateDragNode\n     *  @returns void\n     *  @private\n     */\n    \"_fnCreateDragNode\": function () {\n      var scrolling = this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\";\n      var origCell = this.s.dt.aoColumns[this.s.mouse.targetIndex].nTh;\n      var origTr = origCell.parentNode;\n      var origThead = origTr.parentNode;\n      var origTable = origThead.parentNode;\n      var cloneCell = $(origCell).clone(); // This is a slightly odd combination of jQuery and DOM, but it is the\n      // fastest and least resource intensive way I could think of cloning\n      // the table with just a single header cell in it.\n\n      this.dom.drag = $(origTable.cloneNode(false)).addClass('DTCR_clonedTable').append($(origThead.cloneNode(false)).append($(origTr.cloneNode(false)).append(cloneCell[0]))).css({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        width: $(origCell).outerWidth(),\n        height: $(origCell).outerHeight()\n      }).appendTo('body');\n      this.dom.pointer = $('<div></div>').addClass('DTCR_pointer').css({\n        position: 'absolute',\n        top: scrolling ? $('div.dataTables_scroll', this.s.dt.nTableWrapper).offset().top : $(this.s.dt.nTable).offset().top,\n        height: scrolling ? $('div.dataTables_scroll', this.s.dt.nTableWrapper).height() : $(this.s.dt.nTable).height()\n      }).appendTo('body');\n    },\n\n    /**\n     * Add a data attribute to the column headers, so we know the index of\n     * the row to be reordered. This allows fast detection of the index, and\n     * for this plug-in to work with FixedHeader which clones the nodes.\n     *  @private\n     */\n    \"_fnSetColumnIndexes\": function () {\n      $.each(this.s.dt.aoColumns, function (i, column) {\n        $(column.nTh).attr('data-column-index', i);\n      });\n    },\n\n    /**\n     * Get cursor position regardless of mouse or touch input\n     * @param  {Event}  e    jQuery Event\n     * @param  {string} prop Property to get\n     * @return {number}      Value\n     */\n    _fnCursorPosition: function (e, prop) {\n      if (e.type.indexOf('touch') !== -1) {\n        return e.originalEvent.touches[0][prop];\n      }\n\n      return e[prop];\n    },\n    _fnIsLtr: function () {\n      return $(this.s.dt.nTable).css('direction') !== \"rtl\";\n    }\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Static parameters\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * ColReorder default settings for initialisation\n   *  @namespace\n   *  @static\n   */\n\n  ColReorder.defaults = {\n    /**\n     * Predefined ordering for the columns that will be applied automatically\n     * on initialisation. If not specified then the order that the columns are\n     * found to be in the HTML is the order used.\n     *  @type array\n     *  @default null\n     *  @static\n     */\n    aiOrder: null,\n\n    /**\n     * ColReorder enable on initialisation\n     *  @type boolean\n     *  @default true\n     *  @static\n     */\n    bEnable: true,\n\n    /**\n     * Redraw the table's column ordering as the end user draws the column\n     * (`true`) or wait until the mouse is released (`false` - default). Note\n     * that this will perform a redraw on each reordering, which involves an\n     * Ajax request each time if you are using server-side processing in\n     * DataTables.\n     *  @type boolean\n     *  @default false\n     *  @static\n     */\n    bRealtime: true,\n\n    /**\n     * Indicate how many columns should be fixed in position (counting from the\n     * left). This will typically be 1 if used, but can be as high as you like.\n     *  @type int\n     *  @default 0\n     *  @static\n     */\n    iFixedColumnsLeft: 0,\n\n    /**\n     * As `iFixedColumnsRight` but counting from the right.\n     *  @type int\n     *  @default 0\n     *  @static\n     */\n    iFixedColumnsRight: 0,\n\n    /**\n     * Callback function that is fired when columns are reordered. The `column-\n     * reorder` event is preferred over this callback\n     *  @type function():void\n     *  @default null\n     *  @static\n     */\n    fnReorderCallback: null\n  };\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Constants\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * ColReorder version\n   *  @constant  version\n   *  @type      String\n   *  @default   As code\n   */\n\n  ColReorder.version = \"1.5.4\";\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * DataTables interfaces\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n  // Expose\n\n  $.fn.dataTable.ColReorder = ColReorder;\n  $.fn.DataTable.ColReorder = ColReorder; // Register a new feature with DataTables\n\n  if (typeof $.fn.dataTable == \"function\" && typeof $.fn.dataTableExt.fnVersionCheck == \"function\" && $.fn.dataTableExt.fnVersionCheck('1.10.8')) {\n    $.fn.dataTableExt.aoFeatures.push({\n      \"fnInit\": function (settings) {\n        var table = settings.oInstance;\n\n        if (!settings._colReorder) {\n          var dtInit = settings.oInit;\n          var opts = dtInit.colReorder || dtInit.oColReorder || {};\n          new ColReorder(settings, opts);\n        } else {\n          table.oApi._fnLog(settings, 1, \"ColReorder attempted to initialise twice. Ignoring second\");\n        }\n\n        return null;\n        /* No node for DataTables to insert */\n      },\n      \"cFeature\": \"R\",\n      \"sFeature\": \"ColReorder\"\n    });\n  } else {\n    alert(\"Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download\");\n  } // Attach a listener to the document which listens for DataTables initialisation\n  // events so we can automatically initialise\n\n\n  $(document).on('preInit.dt.colReorder', function (e, settings) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.colReorder;\n    var defaults = DataTable.defaults.colReorder;\n\n    if (init || defaults) {\n      var opts = $.extend({}, init, defaults);\n\n      if (init !== false) {\n        new ColReorder(settings, opts);\n      }\n    }\n  }); // API augmentation\n\n  $.fn.dataTable.Api.register('colReorder.reset()', function () {\n    return this.iterator('table', function (ctx) {\n      ctx._colReorder.fnReset();\n    });\n  });\n  $.fn.dataTable.Api.register('colReorder.order()', function (set, original) {\n    if (set) {\n      return this.iterator('table', function (ctx) {\n        ctx._colReorder.fnOrder(set, original);\n      });\n    }\n\n    return this.context.length ? this.context[0]._colReorder.fnOrder() : null;\n  });\n  $.fn.dataTable.Api.register('colReorder.transpose()', function (idx, dir) {\n    return this.context.length && this.context[0]._colReorder ? this.context[0]._colReorder.fnTranspose(idx, dir) : idx;\n  });\n  $.fn.dataTable.Api.register('colReorder.move()', function (from, to, drop, invalidateRows) {\n    if (this.context.length) {\n      this.context[0]._colReorder.s.dt.oInstance.fnColReorder(from, to, drop, invalidateRows);\n\n      this.context[0]._colReorder._fnSetColumnIndexes();\n    }\n\n    return this;\n  });\n  $.fn.dataTable.Api.register('colReorder.enable()', function (flag) {\n    return this.iterator('table', function (ctx) {\n      if (ctx._colReorder) {\n        ctx._colReorder.fnEnable(flag);\n      }\n    });\n  });\n  $.fn.dataTable.Api.register('colReorder.disable()', function () {\n    return this.iterator('table', function (ctx) {\n      if (ctx._colReorder) {\n        ctx._colReorder.fnDisable();\n      }\n    });\n  });\n  return ColReorder;\n});","map":{"version":3,"sources":["C:/Users/Sher/Desktop/datahub tagging ui/frontend/node_modules/datatables.net-colreorder/js/dataTables.colReorder.js"],"names":["factory","define","amd","$","window","document","exports","module","root","fn","dataTable","require","jQuery","undefined","DataTable","fnInvertKeyValues","aIn","aRet","i","iLen","length","fnArraySwitch","aArray","iFrom","iTo","mStore","splice","fnDomSwitch","nParent","anTags","childNodes","nodeType","push","nStore","insertBefore","appendChild","dataTableExt","oApi","fnColReorder","oSettings","drop","invalidateRows","j","jLen","jen","iCols","aoColumns","nTrs","oCol","attrMap","obj","prop","mapping","a","split","num","shift","isNaN","join","_fnLog","aiMapping","aiInvertMapping","aaSorting","aaSortingFixed","aDataSort","idx","each","aLastSort","val","src","mData","isPlainObject","bVisible","iVisibleIndex","_fnColumnIndexToVisible","iInsertBeforeIndex","nTHead","getElementsByTagName","nTFoot","aoData","nTr","_fnColumnOptions","aoPreSearchCols","data","cells","anCells","_DT_CellIndex","column","Array","isArray","_aData","aoHeader","aoFooter","Api","rows","invalidate","nTh","off","_fnSortAttachListener","oInstance","trigger","from","to","ColReorder","dt","opts","settings","_colReorder","camelToHungarian","defaults","s","extend","dom","enable","init","bEnable","_fnConstruct","prototype","fnEnable","flag","fnDisable","_fnOrderColumns","fnOrder","set","original","ien","columns","_ColReorder_iOrigCol","order","inArray","fnTranspose","dir","map","index","that","table","nTable","iFixedColumns","fixed","iFixedColumnsLeft","fixedRight","iFixedColumnsRight","fnReorderCallback","reorderCallback","_fnMouseListener","_fnCallbackReg","oS","oData","_fnStateSave","call","aiOrder","slice","oLoadedState","_bInitComplete","bDone","on","resort","_fnSetColumnIndexes","removeAttr","changed","currIndex","oScroll","sX","sY","fnAdjustColumnSizing","_fnSaveState","oState","aCopy","iOrigColumn","aSearchCopy","aoSearchCols","abVisCols","stateColumnsCopy","e","which","_fnMouseDown","target","closest","offset","parseInt","attr","mouse","startX","_fnCursorPosition","startY","offsetX","left","offsetY","top","targetIndex","fromIndex","_fnRegions","_fnMouseMove","_fnMouseUp","drag","Math","pow","_fnCreateDragNode","css","lastToIndex","toIndex","cursorXPosiotion","targetsPrev","aoTargets","x","firstNotHidden","lastNotHidden","prevTarget","prevTargetMiddle","_fnIsLtr","pointer","bRealtime","remove","isLTR","lastBound","aoColumnBounds","style","display","nth","bound","outerWidth","firstColumn","firstColumnWidth","columnBound","iToPoint","scrolling","origCell","origTr","parentNode","origThead","origTable","cloneCell","clone","cloneNode","addClass","append","position","width","height","outerHeight","appendTo","nTableWrapper","type","indexOf","originalEvent","touches","version","fnVersionCheck","aoFeatures","dtInit","oInit","colReorder","oColReorder","alert","namespace","register","iterator","ctx","fnReset","context"],"mappings":"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","sourcesContent":["/*! ColReorder 1.5.4\n * Â©2010-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     ColReorder\n * @description Provide the ability to reorder columns in a DataTable\n * @version     1.5.4\n * @file        dataTables.colReorder.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2010-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function( factory ){\n\tif ( typeof define === 'function' && define.amd ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'datatables.net'], function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tmodule.exports = function (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot = window;\n\t\t\t}\n\n\t\t\tif ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net')(root, $).$;\n\t\t\t}\n\n\t\t\treturn factory( $, root, root.document );\n\t\t};\n\t}\n\telse {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Switch the key value pairing of an index array to be value key (i.e. the old value is now the\n * key). For example consider [ 2, 0, 1 ] this would be returned as [ 1, 2, 0 ].\n *  @method  fnInvertKeyValues\n *  @param   array aIn Array to switch around\n *  @returns array\n */\nfunction fnInvertKeyValues( aIn )\n{\n\tvar aRet=[];\n\tfor ( var i=0, iLen=aIn.length ; i<iLen ; i++ )\n\t{\n\t\taRet[ aIn[i] ] = i;\n\t}\n\treturn aRet;\n}\n\n\n/**\n * Modify an array by switching the position of two elements\n *  @method  fnArraySwitch\n *  @param   array aArray Array to consider, will be modified by reference (i.e. no return)\n *  @param   int iFrom From point\n *  @param   int iTo Insert point\n *  @returns void\n */\nfunction fnArraySwitch( aArray, iFrom, iTo )\n{\n\tvar mStore = aArray.splice( iFrom, 1 )[0];\n\taArray.splice( iTo, 0, mStore );\n}\n\n\n/**\n * Switch the positions of nodes in a parent node (note this is specifically designed for\n * table rows). Note this function considers all element nodes under the parent!\n *  @method  fnDomSwitch\n *  @param   string sTag Tag to consider\n *  @param   int iFrom Element to move\n *  @param   int Point to element the element to (before this point), can be null for append\n *  @returns void\n */\nfunction fnDomSwitch( nParent, iFrom, iTo )\n{\n\tvar anTags = [];\n\tfor ( var i=0, iLen=nParent.childNodes.length ; i<iLen ; i++ )\n\t{\n\t\tif ( nParent.childNodes[i].nodeType == 1 )\n\t\t{\n\t\t\tanTags.push( nParent.childNodes[i] );\n\t\t}\n\t}\n\tvar nStore = anTags[ iFrom ];\n\n\tif ( iTo !== null )\n\t{\n\t\tnParent.insertBefore( nStore, anTags[iTo] );\n\t}\n\telse\n\t{\n\t\tnParent.appendChild( nStore );\n\t}\n}\n\n\n/**\n * Plug-in for DataTables which will reorder the internal column structure by taking the column\n * from one position (iFrom) and insert it into a given point (iTo).\n *  @method  $.fn.dataTableExt.oApi.fnColReorder\n *  @param   object oSettings DataTables settings object - automatically added by DataTables!\n *  @param   int iFrom Take the column to be repositioned from this point\n *  @param   int iTo and insert it into this point\n *  @param   bool drop Indicate if the reorder is the final one (i.e. a drop)\n *    not a live reorder\n *  @param   bool invalidateRows speeds up processing if false passed\n *  @returns void\n */\n$.fn.dataTableExt.oApi.fnColReorder = function ( oSettings, iFrom, iTo, drop, invalidateRows )\n{\n\tvar i, iLen, j, jLen, jen, iCols=oSettings.aoColumns.length, nTrs, oCol;\n\tvar attrMap = function ( obj, prop, mapping ) {\n\t\tif ( ! obj[ prop ] || typeof obj[ prop ] === 'function' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar a = obj[ prop ].split('.');\n\t\tvar num = a.shift();\n\n\t\tif ( isNaN( num*1 ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tobj[ prop ] = mapping[ num*1 ]+'.'+a.join('.');\n\t};\n\n\t/* Sanity check in the input */\n\tif ( iFrom == iTo )\n\t{\n\t\t/* Pointless reorder */\n\t\treturn;\n\t}\n\n\tif ( iFrom < 0 || iFrom >= iCols )\n\t{\n\t\tthis.oApi._fnLog( oSettings, 1, \"ColReorder 'from' index is out of bounds: \"+iFrom );\n\t\treturn;\n\t}\n\n\tif ( iTo < 0 || iTo >= iCols )\n\t{\n\t\tthis.oApi._fnLog( oSettings, 1, \"ColReorder 'to' index is out of bounds: \"+iTo );\n\t\treturn;\n\t}\n\n\t/*\n\t * Calculate the new column array index, so we have a mapping between the old and new\n\t */\n\tvar aiMapping = [];\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\taiMapping[i] = i;\n\t}\n\tfnArraySwitch( aiMapping, iFrom, iTo );\n\tvar aiInvertMapping = fnInvertKeyValues( aiMapping );\n\n\n\t/*\n\t * Convert all internal indexing to the new column order indexes\n\t */\n\t/* Sorting */\n\tfor ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )\n\t{\n\t\toSettings.aaSorting[i][0] = aiInvertMapping[ oSettings.aaSorting[i][0] ];\n\t}\n\n\t/* Fixed sorting */\n\tif ( oSettings.aaSortingFixed !== null )\n\t{\n\t\tfor ( i=0, iLen=oSettings.aaSortingFixed.length ; i<iLen ; i++ )\n\t\t{\n\t\t\toSettings.aaSortingFixed[i][0] = aiInvertMapping[ oSettings.aaSortingFixed[i][0] ];\n\t\t}\n\t}\n\n\t/* Data column sorting (the column which the sort for a given column should take place on) */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\toCol = oSettings.aoColumns[i];\n\t\tfor ( j=0, jLen=oCol.aDataSort.length ; j<jLen ; j++ )\n\t\t{\n\t\t\toCol.aDataSort[j] = aiInvertMapping[ oCol.aDataSort[j] ];\n\t\t}\n\n\t\t// Update the column indexes\n\t\toCol.idx = aiInvertMapping[ oCol.idx ];\n\t}\n\n\t// Update 1.10 optimised sort class removal variable\n\t$.each( oSettings.aLastSort, function (i, val) {\n\t\toSettings.aLastSort[i].src = aiInvertMapping[ val.src ];\n\t} );\n\n\t/* Update the Get and Set functions for each column */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\toCol = oSettings.aoColumns[i];\n\n\t\tif ( typeof oCol.mData == 'number' ) {\n\t\t\toCol.mData = aiInvertMapping[ oCol.mData ];\n\t\t}\n\t\telse if ( $.isPlainObject( oCol.mData ) ) {\n\t\t\t// HTML5 data sourced\n\t\t\tattrMap( oCol.mData, '_',      aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'filter', aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'sort',   aiInvertMapping );\n\t\t\tattrMap( oCol.mData, 'type',   aiInvertMapping );\n\t\t}\n\t}\n\n\t/*\n\t * Move the DOM elements\n\t */\n\tif ( oSettings.aoColumns[iFrom].bVisible )\n\t{\n\t\t/* Calculate the current visible index and the point to insert the node before. The insert\n\t\t * before needs to take into account that there might not be an element to insert before,\n\t\t * in which case it will be null, and an appendChild should be used\n\t\t */\n\t\tvar iVisibleIndex = this.oApi._fnColumnIndexToVisible( oSettings, iFrom );\n\t\tvar iInsertBeforeIndex = null;\n\n\t\ti = iTo < iFrom ? iTo : iTo + 1;\n\t\twhile ( iInsertBeforeIndex === null && i < iCols )\n\t\t{\n\t\t\tiInsertBeforeIndex = this.oApi._fnColumnIndexToVisible( oSettings, i );\n\t\t\ti++;\n\t\t}\n\n\t\t/* Header */\n\t\tnTrs = oSettings.nTHead.getElementsByTagName('tr');\n\t\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );\n\t\t}\n\n\t\t/* Footer */\n\t\tif ( oSettings.nTFoot !== null )\n\t\t{\n\t\t\tnTrs = oSettings.nTFoot.getElementsByTagName('tr');\n\t\t\tfor ( i=0, iLen=nTrs.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tfnDomSwitch( nTrs[i], iVisibleIndex, iInsertBeforeIndex );\n\t\t\t}\n\t\t}\n\n\t\t/* Body */\n\t\tfor ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tif ( oSettings.aoData[i].nTr !== null )\n\t\t\t{\n\t\t\t\tfnDomSwitch( oSettings.aoData[i].nTr, iVisibleIndex, iInsertBeforeIndex );\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Move the internal array elements\n\t */\n\t/* Columns */\n\tfnArraySwitch( oSettings.aoColumns, iFrom, iTo );\n\n\t// regenerate the get / set functions\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ ) {\n\t\toSettings.oApi._fnColumnOptions( oSettings, i, {} );\n\t}\n\n\t/* Search columns */\n\tfnArraySwitch( oSettings.aoPreSearchCols, iFrom, iTo );\n\n\t/* Array array - internal data anodes cache */\n\tfor ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )\n\t{\n\t\tvar data = oSettings.aoData[i];\n\t\tvar cells = data.anCells;\n\n\t\tif ( cells ) {\n\t\t\tfnArraySwitch( cells, iFrom, iTo );\n\n\t\t\t// Longer term, should this be moved into the DataTables' invalidate\n\t\t\t// methods?\n\t\t\tfor ( j=0, jen=cells.length ; j<jen ; j++ ) {\n\t\t\t\tif ( cells[j] && cells[j]._DT_CellIndex ) {\n\t\t\t\t\tcells[j]._DT_CellIndex.column = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// For DOM sourced data, the invalidate will reread the cell into\n\t\t// the data array, but for data sources as an array, they need to\n\t\t// be flipped\n\t\tif ( data.src !== 'dom' && Array.isArray( data._aData ) ) {\n\t\t\tfnArraySwitch( data._aData, iFrom, iTo );\n\t\t}\n\t}\n\n\t/* Reposition the header elements in the header layout array */\n\tfor ( i=0, iLen=oSettings.aoHeader.length ; i<iLen ; i++ )\n\t{\n\t\tfnArraySwitch( oSettings.aoHeader[i], iFrom, iTo );\n\t}\n\n\tif ( oSettings.aoFooter !== null )\n\t{\n\t\tfor ( i=0, iLen=oSettings.aoFooter.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tfnArraySwitch( oSettings.aoFooter[i], iFrom, iTo );\n\t\t}\n\t}\n\n\tif ( invalidateRows || invalidateRows === undefined )\n\t{\n\t\t$.fn.dataTable.Api( oSettings ).rows().invalidate();\n\t}\n\n\t/*\n\t * Update DataTables' event handlers\n\t */\n\n\t/* Sort listener */\n\tfor ( i=0, iLen=iCols ; i<iLen ; i++ )\n\t{\n\t\t$(oSettings.aoColumns[i].nTh).off('.DT');\n\t\tthis.oApi._fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );\n\t}\n\n\n\t/* Fire an event so other plug-ins can update */\n\t$(oSettings.oInstance).trigger( 'column-reorder.dt', [ oSettings, {\n\t\tfrom: iFrom,\n\t\tto: iTo,\n\t\tmapping: aiInvertMapping,\n\t\tdrop: drop,\n\n\t\t// Old style parameters for compatibility\n\t\tiFrom: iFrom,\n\t\tiTo: iTo,\n\t\taiInvertMapping: aiInvertMapping\n\t} ] );\n};\n\n/**\n * ColReorder provides column visibility control for DataTables\n * @class ColReorder\n * @constructor\n * @param {object} dt DataTables settings object\n * @param {object} opts ColReorder options\n */\nvar ColReorder = function( dt, opts )\n{\n\tvar settings = new $.fn.dataTable.Api( dt ).settings()[0];\n\n\t// Ensure that we can't initialise on the same table twice\n\tif ( settings._colReorder ) {\n\t\treturn settings._colReorder;\n\t}\n\n\t// Allow the options to be a boolean for defaults\n\tif ( opts === true ) {\n\t\topts = {};\n\t}\n\n\t// Convert from camelCase to Hungarian, just as DataTables does\n\tvar camelToHungarian = $.fn.dataTable.camelToHungarian;\n\tif ( camelToHungarian ) {\n\t\tcamelToHungarian( ColReorder.defaults, ColReorder.defaults, true );\n\t\tcamelToHungarian( ColReorder.defaults, opts || {} );\n\t}\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public class variables\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * @namespace Settings object which contains customisable information for ColReorder instance\n\t */\n\tthis.s = {\n\t\t/**\n\t\t * DataTables settings object\n\t\t *  @property dt\n\t\t *  @type     Object\n\t\t *  @default  null\n\t\t */\n\t\t\"dt\": null,\n\n\t\t/**\n\t\t * Enable flag\n\t\t *  @property dt\n\t\t *  @type     Object\n\t\t *  @default  null\n\t\t */\n\t\t\"enable\": null,\n\n\t\t/**\n\t\t * Initialisation object used for this instance\n\t\t *  @property init\n\t\t *  @type     object\n\t\t *  @default  {}\n\t\t */\n\t\t\"init\": $.extend( true, {}, ColReorder.defaults, opts ),\n\n\t\t/**\n\t\t * Number of columns to fix (not allow to be reordered)\n\t\t *  @property fixed\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\t\"fixed\": 0,\n\n\t\t/**\n\t\t * Number of columns to fix counting from right (not allow to be reordered)\n\t\t *  @property fixedRight\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\t\"fixedRight\": 0,\n\n\t\t/**\n\t\t * Callback function for once the reorder has been done\n\t\t *  @property reorderCallback\n\t\t *  @type     function\n\t\t *  @default  null\n\t\t */\n\t\t\"reorderCallback\": null,\n\n\t\t/**\n\t\t * @namespace Information used for the mouse drag\n\t\t */\n\t\t\"mouse\": {\n\t\t\t\"startX\": -1,\n\t\t\t\"startY\": -1,\n\t\t\t\"offsetX\": -1,\n\t\t\t\"offsetY\": -1,\n\t\t\t\"target\": -1,\n\t\t\t\"targetIndex\": -1,\n\t\t\t\"fromIndex\": -1\n\t\t},\n\n\t\t/**\n\t\t * Information which is used for positioning the insert cusor and knowing where to do the\n\t\t * insert. Array of objects with the properties:\n\t\t *   x: x-axis position\n\t\t *   to: insert point\n\t\t *  @property aoTargets\n\t\t *  @type     array\n\t\t *  @default  []\n\t\t */\n\t\t\"aoTargets\": []\n\t};\n\n\n\t/**\n\t * @namespace Common and useful DOM elements for the class instance\n\t */\n\tthis.dom = {\n\t\t/**\n\t\t * Dragging element (the one the mouse is moving)\n\t\t *  @property drag\n\t\t *  @type     element\n\t\t *  @default  null\n\t\t */\n\t\t\"drag\": null,\n\n\t\t/**\n\t\t * The insert cursor\n\t\t *  @property pointer\n\t\t *  @type     element\n\t\t *  @default  null\n\t\t */\n\t\t\"pointer\": null\n\t};\n\n\t/* Constructor logic */\n\tthis.s.enable = this.s.init.bEnable;\n\tthis.s.dt = settings;\n\tthis.s.dt._colReorder = this;\n\tthis._fnConstruct();\n\n\treturn this;\n};\n\n\n\n$.extend( ColReorder.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * Enable / disable end user interaction\n\t */\n\tfnEnable: function ( flag )\n\t{\n\t\tif ( flag === false ) {\n\t\t\treturn fnDisable();\n\t\t}\n\n\t\tthis.s.enable = true;\n\t},\n\n\t/**\n\t * Disable end user interaction\n\t */\n\tfnDisable: function ()\n\t{\n\t\tthis.s.enable = false;\n\t},\n\n\t/**\n\t * Reset the column ordering to the original ordering that was detected on\n\t * start up.\n\t *  @return {this} Returns `this` for chaining.\n\t *\n\t *  @example\n\t *    // DataTables initialisation with ColReorder\n\t *    var table = $('#example').dataTable( {\n\t *        \"sDom\": 'Rlfrtip'\n\t *    } );\n\t *\n\t *    // Add click event to a button to reset the ordering\n\t *    $('#resetOrdering').click( function (e) {\n\t *        e.preventDefault();\n\t *        $.fn.dataTable.ColReorder( table ).fnReset();\n\t *    } );\n\t */\n\t\"fnReset\": function ()\n\t{\n\t\tthis._fnOrderColumns( this.fnOrder() );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * `Deprecated` - Get the current order of the columns, as an array.\n\t *  @return {array} Array of column identifiers\n\t *  @deprecated `fnOrder` should be used in preference to this method.\n\t *      `fnOrder` acts as a getter/setter.\n\t */\n\t\"fnGetCurrentOrder\": function ()\n\t{\n\t\treturn this.fnOrder();\n\t},\n\n\t/**\n\t * Get the current order of the columns, as an array. Note that the values\n\t * given in the array are unique identifiers for each column. Currently\n\t * these are the original ordering of the columns that was detected on\n\t * start up, but this could potentially change in future.\n\t *  @return {array} Array of column identifiers\n\t *\n\t *  @example\n\t *    // Get column ordering for the table\n\t *    var order = $.fn.dataTable.ColReorder( dataTable ).fnOrder();\n\t *//**\n\t * Set the order of the columns, from the positions identified in the\n\t * ordering array given. Note that ColReorder takes a brute force approach\n\t * to reordering, so it is possible multiple reordering events will occur\n\t * before the final order is settled upon.\n\t *  @param {array} [set] Array of column identifiers in the new order. Note\n\t *    that every column must be included, uniquely, in this array.\n\t *  @return {this} Returns `this` for chaining.\n\t *\n\t *  @example\n\t *    // Swap the first and second columns\n\t *    $.fn.dataTable.ColReorder( dataTable ).fnOrder( [1, 0, 2, 3, 4] );\n\t *\n\t *  @example\n\t *    // Move the first column to the end for the table `#example`\n\t *    var curr = $.fn.dataTable.ColReorder( '#example' ).fnOrder();\n\t *    var first = curr.shift();\n\t *    curr.push( first );\n\t *    $.fn.dataTable.ColReorder( '#example' ).fnOrder( curr );\n\t *\n\t *  @example\n\t *    // Reverse the table's order\n\t *    $.fn.dataTable.ColReorder( '#example' ).fnOrder(\n\t *      $.fn.dataTable.ColReorder( '#example' ).fnOrder().reverse()\n\t *    );\n\t */\n\t\"fnOrder\": function ( set, original )\n\t{\n\t\tvar a = [], i, ien, j, jen;\n\t\tvar columns = this.s.dt.aoColumns;\n\n\t\tif ( set === undefined ){\n\t\t\tfor ( i=0, ien=columns.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( columns[i]._ColReorder_iOrigCol );\n\t\t\t}\n\n\t\t\treturn a;\n\t\t}\n\n\t\t// The order given is based on the original indexes, rather than the\n\t\t// existing ones, so we need to translate from the original to current\n\t\t// before then doing the order\n\t\tif ( original ) {\n\t\t\tvar order = this.fnOrder();\n\n\t\t\tfor ( i=0, ien=set.length ; i<ien ; i++ ) {\n\t\t\t\ta.push( $.inArray( set[i], order ) );\n\t\t\t}\n\n\t\t\tset = a;\n\t\t}\n\n\t\tthis._fnOrderColumns( fnInvertKeyValues( set ) );\n\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Convert from the original column index, to the original\n\t *\n\t * @param  {int|array} idx Index(es) to convert\n\t * @param  {string} dir Transpose direction - `fromOriginal` / `toCurrent`\n\t *   or `'toOriginal` / `fromCurrent`\n\t * @return {int|array}     Converted values\n\t */\n\tfnTranspose: function ( idx, dir )\n\t{\n\t\tif ( ! dir ) {\n\t\t\tdir = 'toCurrent';\n\t\t}\n\n\t\tvar order = this.fnOrder();\n\t\tvar columns = this.s.dt.aoColumns;\n\n\t\tif ( dir === 'toCurrent' ) {\n\t\t\t// Given an original index, want the current\n\t\t\treturn ! Array.isArray( idx ) ?\n\t\t\t\t$.inArray( idx, order ) :\n\t\t\t\t$.map( idx, function ( index ) {\n\t\t\t\t\treturn $.inArray( index, order );\n\t\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\t// Given a current index, want the original\n\t\t\treturn ! Array.isArray( idx ) ?\n\t\t\t\tcolumns[idx]._ColReorder_iOrigCol :\n\t\t\t\t$.map( idx, function ( index ) {\n\t\t\t\t\treturn columns[index]._ColReorder_iOrigCol;\n\t\t\t\t} );\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods (they are of course public in JS, but recommended as private)\n\t * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\t/**\n\t * Constructor logic\n\t *  @method  _fnConstruct\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnConstruct\": function ()\n\t{\n\t\tvar that = this;\n\t\tvar iLen = this.s.dt.aoColumns.length;\n\t\tvar table = this.s.dt.nTable;\n\t\tvar i;\n\n\t\t/* Columns discounted from reordering - counting left to right */\n\t\tif ( this.s.init.iFixedColumns )\n\t\t{\n\t\t\tthis.s.fixed = this.s.init.iFixedColumns;\n\t\t}\n\n\t\tif ( this.s.init.iFixedColumnsLeft )\n\t\t{\n\t\t\tthis.s.fixed = this.s.init.iFixedColumnsLeft;\n\t\t}\n\n\t\t/* Columns discounted from reordering - counting right to left */\n\t\tthis.s.fixedRight = this.s.init.iFixedColumnsRight ?\n\t\t\tthis.s.init.iFixedColumnsRight :\n\t\t\t0;\n\n\t\t/* Drop callback initialisation option */\n\t\tif ( this.s.init.fnReorderCallback )\n\t\t{\n\t\t\tthis.s.reorderCallback = this.s.init.fnReorderCallback;\n\t\t}\n\n\t\t/* Add event handlers for the drag and drop, and also mark the original column order */\n\t\tfor ( i = 0; i < iLen; i++ )\n\t\t{\n\t\t\tif ( i > this.s.fixed-1 && i < iLen - this.s.fixedRight )\n\t\t\t{\n\t\t\t\tthis._fnMouseListener( i, this.s.dt.aoColumns[i].nTh );\n\t\t\t}\n\n\t\t\t/* Mark the original column order for later reference */\n\t\t\tthis.s.dt.aoColumns[i]._ColReorder_iOrigCol = i;\n\t\t}\n\n\t\t/* State saving */\n\t\tthis.s.dt.oApi._fnCallbackReg( this.s.dt, 'aoStateSaveParams', function (oS, oData) {\n\t\t\tthat._fnStateSave.call( that, oData );\n\t\t}, \"ColReorder_State\" );\n\n\t\t/* An initial column order has been specified */\n\t\tvar aiOrder = null;\n\t\tif ( this.s.init.aiOrder )\n\t\t{\n\t\t\taiOrder = this.s.init.aiOrder.slice();\n\t\t}\n\n\t\t/* State loading, overrides the column order given */\n\t\tif ( this.s.dt.oLoadedState && typeof this.s.dt.oLoadedState.ColReorder != 'undefined' &&\n\t\t  this.s.dt.oLoadedState.ColReorder.length == this.s.dt.aoColumns.length )\n\t\t{\n\t\t\taiOrder = this.s.dt.oLoadedState.ColReorder;\n\t\t}\n\n\t\t/* If we have an order to apply - do so */\n\t\tif ( aiOrder )\n\t\t{\n\t\t\t/* We might be called during or after the DataTables initialisation. If before, then we need\n\t\t\t * to wait until the draw is done, if after, then do what we need to do right away\n\t\t\t */\n\t\t\tif ( !that.s.dt._bInitComplete )\n\t\t\t{\n\t\t\t\tvar bDone = false;\n\t\t\t\t$(table).on( 'draw.dt.colReorder', function () {\n\t\t\t\t\tif ( !that.s.dt._bInitComplete && !bDone )\n\t\t\t\t\t{\n\t\t\t\t\t\tbDone = true;\n\t\t\t\t\t\tvar resort = fnInvertKeyValues( aiOrder );\n\t\t\t\t\t\tthat._fnOrderColumns.call( that, resort );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar resort = fnInvertKeyValues( aiOrder );\n\t\t\t\tthat._fnOrderColumns.call( that, resort );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._fnSetColumnIndexes();\n\t\t}\n\n\t\t// Destroy clean up\n\t\t$(table).on( 'destroy.dt.colReorder', function () {\n\t\t\t$(table).off( 'destroy.dt.colReorder draw.dt.colReorder' );\n\n\t\t\t$.each( that.s.dt.aoColumns, function (i, column) {\n\t\t\t\t$(column.nTh).off('.ColReorder');\n\t\t\t\t$(column.nTh).removeAttr('data-column-index');\n\t\t\t} );\n\n\t\t\tthat.s.dt._colReorder = null;\n\t\t\tthat.s = null;\n\t\t} );\n\t},\n\n\n\t/**\n\t * Set the column order from an array\n\t *  @method  _fnOrderColumns\n\t *  @param   array a An array of integers which dictate the column order that should be applied\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnOrderColumns\": function ( a )\n\t{\n\t\tvar changed = false;\n\n\t\tif ( a.length != this.s.dt.aoColumns.length )\n\t\t{\n\t\t\tthis.s.dt.oInstance.oApi._fnLog( this.s.dt, 1, \"ColReorder - array reorder does not \"+\n\t\t\t\t\"match known number of columns. Skipping.\" );\n\t\t\treturn;\n\t\t}\n\n\t\tfor ( var i=0, iLen=a.length ; i<iLen ; i++ )\n\t\t{\n\t\t\tvar currIndex = $.inArray( i, a );\n\t\t\tif ( i != currIndex )\n\t\t\t{\n\t\t\t\t/* Reorder our switching array */\n\t\t\t\tfnArraySwitch( a, currIndex, i );\n\n\t\t\t\t/* Do the column reorder in the table */\n\t\t\t\tthis.s.dt.oInstance.fnColReorder( currIndex, i, true, false );\n\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._fnSetColumnIndexes();\n\n\t\t// Has anything actually changed? If not, then nothing else to do\n\t\tif ( ! changed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t$.fn.dataTable.Api( this.s.dt ).rows().invalidate();\n\n\t\t/* When scrolling we need to recalculate the column sizes to allow for the shift */\n\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t{\n\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t}\n\n\t\t/* Save the state */\n\t\tthis.s.dt.oInstance.oApi._fnSaveState( this.s.dt );\n\n\t\tif ( this.s.reorderCallback !== null )\n\t\t{\n\t\t\tthis.s.reorderCallback.call( this );\n\t\t}\n\t},\n\n\n\t/**\n\t * Because we change the indexes of columns in the table, relative to their starting point\n\t * we need to reorder the state columns to what they are at the starting point so we can\n\t * then rearrange them again on state load!\n\t *  @method  _fnStateSave\n\t *  @param   object oState DataTables state\n\t *  @returns string JSON encoded cookie string for DataTables\n\t *  @private\n\t */\n\t\"_fnStateSave\": function ( oState )\n\t{\n\t\tvar i, iLen, aCopy, iOrigColumn;\n\t\tvar oSettings = this.s.dt;\n\t\tvar columns = oSettings.aoColumns;\n\n\t\toState.ColReorder = [];\n\n\t\t/* Sorting */\n\t\tif ( oState.aaSorting ) {\n\t\t\t// 1.10.0-\n\t\t\tfor ( i=0 ; i<oState.aaSorting.length ; i++ ) {\n\t\t\t\toState.aaSorting[i][0] = columns[ oState.aaSorting[i][0] ]._ColReorder_iOrigCol;\n\t\t\t}\n\n\t\t\tvar aSearchCopy = $.extend( true, [], oState.aoSearchCols );\n\n\t\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n\t\t\t\t/* Column filter */\n\t\t\t\toState.aoSearchCols[ iOrigColumn ] = aSearchCopy[i];\n\n\t\t\t\t/* Visibility */\n\t\t\t\toState.abVisCols[ iOrigColumn ] = columns[i].bVisible;\n\n\t\t\t\t/* Column reordering */\n\t\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t\t}\n\t\t}\n\t\telse if ( oState.order ) {\n\t\t\t// 1.10.1+\n\t\t\tfor ( i=0 ; i<oState.order.length ; i++ ) {\n\t\t\t\toState.order[i][0] = columns[ oState.order[i][0] ]._ColReorder_iOrigCol;\n\t\t\t}\n\n\t\t\tvar stateColumnsCopy = $.extend( true, [], oState.columns );\n\n\t\t\tfor ( i=0, iLen=columns.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\tiOrigColumn = columns[i]._ColReorder_iOrigCol;\n\n\t\t\t\t/* Columns */\n\t\t\t\toState.columns[ iOrigColumn ] = stateColumnsCopy[i];\n\n\t\t\t\t/* Column reordering */\n\t\t\t\toState.ColReorder.push( iOrigColumn );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Mouse drop and drag\n\t */\n\n\t/**\n\t * Add a mouse down listener to a particluar TH element\n\t *  @method  _fnMouseListener\n\t *  @param   int i Column index\n\t *  @param   element nTh TH element clicked on\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseListener\": function ( i, nTh )\n\t{\n\t\tvar that = this;\n\t\t$(nTh)\n\t\t\t.on( 'mousedown.ColReorder', function (e) {\n\t\t\t\tif ( that.s.enable && e.which === 1 ) {\n\t\t\t\t\tthat._fnMouseDown.call( that, e, nTh );\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.on( 'touchstart.ColReorder', function (e) {\n\t\t\t\tif ( that.s.enable ) {\n\t\t\t\t\tthat._fnMouseDown.call( that, e, nTh );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\n\n\t/**\n\t * Mouse down on a TH element in the table header\n\t *  @method  _fnMouseDown\n\t *  @param   event e Mouse event\n\t *  @param   element nTh TH element to be dragged\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseDown\": function ( e, nTh )\n\t{\n\t\tvar that = this;\n\n\t\t/* Store information about the mouse position */\n\t\tvar target = $(e.target).closest('th, td');\n\t\tvar offset = target.offset();\n\t\tvar idx = parseInt( $(nTh).attr('data-column-index'), 10 );\n\n\t\tif ( idx === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.s.mouse.startX = this._fnCursorPosition( e, 'pageX' );\n\t\tthis.s.mouse.startY = this._fnCursorPosition( e, 'pageY' );\n\t\tthis.s.mouse.offsetX = this._fnCursorPosition( e, 'pageX' ) - offset.left;\n\t\tthis.s.mouse.offsetY = this._fnCursorPosition( e, 'pageY' ) - offset.top;\n\t\tthis.s.mouse.target = this.s.dt.aoColumns[ idx ].nTh;//target[0];\n\t\tthis.s.mouse.targetIndex = idx;\n\t\tthis.s.mouse.fromIndex = idx;\n\n\t\tthis._fnRegions();\n\n\t\t/* Add event handlers to the document */\n\t\t$(document)\n\t\t\t.on( 'mousemove.ColReorder touchmove.ColReorder', function (e) {\n\t\t\t\tthat._fnMouseMove.call( that, e );\n\t\t\t} )\n\t\t\t.on( 'mouseup.ColReorder touchend.ColReorder', function (e) {\n\t\t\t\tthat._fnMouseUp.call( that, e );\n\t\t\t} );\n\t},\n\n\n\t/**\n\t * Deal with a mouse move event while dragging a node\n\t *  @method  _fnMouseMove\n\t *  @param   event e Mouse event\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseMove\": function ( e )\n\t{\n\t\tvar that = this;\n\n\t\tif ( this.dom.drag === null )\n\t\t{\n\t\t\t/* Only create the drag element if the mouse has moved a specific distance from the start\n\t\t\t * point - this allows the user to make small mouse movements when sorting and not have a\n\t\t\t * possibly confusing drag element showing up\n\t\t\t */\n\t\t\tif ( Math.pow(\n\t\t\t\tMath.pow(this._fnCursorPosition( e, 'pageX') - this.s.mouse.startX, 2) +\n\t\t\t\tMath.pow(this._fnCursorPosition( e, 'pageY') - this.s.mouse.startY, 2), 0.5 ) < 5 )\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._fnCreateDragNode();\n\t\t}\n\n\t\t/* Position the element - we respect where in the element the click occured */\n\t\tthis.dom.drag.css( {\n\t\t\tleft: this._fnCursorPosition( e, 'pageX' ) - this.s.mouse.offsetX,\n\t\t\ttop: this._fnCursorPosition( e, 'pageY' ) - this.s.mouse.offsetY\n\t\t} );\n\n\t\t/* Based on the current mouse position, calculate where the insert should go */\n\t\tvar target;\n\t\tvar lastToIndex = this.s.mouse.toIndex;\n\t\tvar cursorXPosiotion = this._fnCursorPosition(e, 'pageX');\n\t\tvar targetsPrev = function (i) {\n\t\t\twhile (i >= 0) {\n\t\t\t\ti--;\n\n\t\t\t\tif (i <= 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (that.s.aoTargets[i+1].x !== that.s.aoTargets[i].x) {\n\t\t\t\t\treturn that.s.aoTargets[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar firstNotHidden = function () {\n\t\t\tfor (var i=0 ; i<that.s.aoTargets.length-1 ; i++) {\n\t\t\t\tif (that.s.aoTargets[i].x !== that.s.aoTargets[i+1].x) {\n\t\t\t\t\treturn that.s.aoTargets[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tvar lastNotHidden = function () {\n\t\t\tfor (var i=that.s.aoTargets.length-1 ; i>0 ; i--) {\n\t\t\t\tif (that.s.aoTargets[i].x !== that.s.aoTargets[i-1].x) {\n\t\t\t\t\treturn that.s.aoTargets[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n        for (var i = 1; i < this.s.aoTargets.length; i++) {\n\t\t\tvar prevTarget = targetsPrev(i);\n\t\t\tif (! prevTarget) {\n\t\t\t\tprevTarget = firstNotHidden();\n\t\t\t}\n\n\t\t\tvar prevTargetMiddle = prevTarget.x + (this.s.aoTargets[i].x - prevTarget.x) / 2;\n\n            if (this._fnIsLtr()) {\n                if (cursorXPosiotion < prevTargetMiddle ) {\n                    target = prevTarget;\n                    break;\n                }\n            }\n            else {\n                if (cursorXPosiotion > prevTargetMiddle) {\n                    target = prevTarget;\n                    break;\n                }\n            }\n\t\t}\n\n        if (target) {\n            this.dom.pointer.css('left', target.x);\n            this.s.mouse.toIndex = target.to;\n        }\n        else {\n\t\t\t// The insert element wasn't positioned in the array (less than\n\t\t\t// operator), so we put it at the end\n\t\t\tthis.dom.pointer.css( 'left', lastNotHidden().x );\n\t\t\tthis.s.mouse.toIndex = lastNotHidden().to;\n\t\t}\n\n\t\t// Perform reordering if realtime updating is on and the column has moved\n\t\tif ( this.s.init.bRealtime && lastToIndex !== this.s.mouse.toIndex ) {\n\t\t\tthis.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex );\n\t\t\tthis.s.mouse.fromIndex = this.s.mouse.toIndex;\n\n\t\t\t// Not great for performance, but required to keep everything in alignment\n\t\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t\t{\n\t\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t\t}\n\n\t\t\tthis._fnRegions();\n\t\t}\n\t},\n\n\n\t/**\n\t * Finish off the mouse drag and insert the column where needed\n\t *  @method  _fnMouseUp\n\t *  @param   event e Mouse event\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnMouseUp\": function ( e )\n\t{\n\t\tvar that = this;\n\n\t\t$(document).off( '.ColReorder' );\n\n\t\tif ( this.dom.drag !== null )\n\t\t{\n\t\t\t/* Remove the guide elements */\n\t\t\tthis.dom.drag.remove();\n\t\t\tthis.dom.pointer.remove();\n\t\t\tthis.dom.drag = null;\n\t\t\tthis.dom.pointer = null;\n\n\t\t\t/* Actually do the reorder */\n\t\t\tthis.s.dt.oInstance.fnColReorder( this.s.mouse.fromIndex, this.s.mouse.toIndex, true );\n\t\t\tthis._fnSetColumnIndexes();\n\n\t\t\t/* When scrolling we need to recalculate the column sizes to allow for the shift */\n\t\t\tif ( this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\" )\n\t\t\t{\n\t\t\t\tthis.s.dt.oInstance.fnAdjustColumnSizing( false );\n\t\t\t}\n\n\t\t\t/* Save the state */\n\t\t\tthis.s.dt.oInstance.oApi._fnSaveState( this.s.dt );\n\n\t\t\tif ( this.s.reorderCallback !== null )\n\t\t\t{\n\t\t\t\tthis.s.reorderCallback.call( this );\n\t\t\t}\n\t\t}\n\t},\n\n\n\t/**\n\t * Calculate a cached array with the points of the column inserts, and the\n\t * 'to' points\n\t *  @method  _fnRegions\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnRegions\": function ()\n\t{\n\t\tvar aoColumns = this.s.dt.aoColumns;\n        var isLTR = this._fnIsLtr();\n\t\tthis.s.aoTargets.splice(0, this.s.aoTargets.length);\n\t\tvar lastBound = $(this.s.dt.nTable).offset().left;\n\n        var aoColumnBounds = [];\n        $.each(aoColumns, function (i, column) {\n            if (column.bVisible && column.nTh.style.display !== 'none') {\n                var nth = $(column.nTh);\n\t\t\t\tvar bound = nth.offset().left;\n\n                if (isLTR) {\n                    bound += nth.outerWidth();\n                }\n\n                aoColumnBounds.push({\n                    index: i,\n                    bound: bound\n\t\t\t\t});\n\n\t\t\t\tlastBound = bound;\n\t\t\t}\n\t\t\telse {\n                aoColumnBounds.push({\n\t\t\t\t\tindex: i,\n\t\t\t\t\tbound: lastBound\n                });\n\t\t\t}\n\t\t});\n\n        var firstColumn = aoColumnBounds[0];\n\t\tvar firstColumnWidth = $(aoColumns[firstColumn.index].nTh).outerWidth();\n\n        this.s.aoTargets.push({\n            to: 0,\n\t\t\tx: firstColumn.bound - firstColumnWidth\n        });\n\n        for (var i = 0; i < aoColumnBounds.length; i++) {\n            var columnBound = aoColumnBounds[i];\n            var iToPoint = columnBound.index;\n\n            /* For the column / header in question, we want it's position to remain the same if the\n            * position is just to it's immediate left or right, so we only increment the counter for\n            * other columns\n            */\n            if (columnBound.index < this.s.mouse.fromIndex) {\n                iToPoint++;\n            }\n\n            this.s.aoTargets.push({\n\t\t\t\tto: iToPoint,\n                x: columnBound.bound\n            });\n        }\n\n\t\t/* Disallow columns for being reordered by drag and drop, counting right to left */\n\t\tif ( this.s.fixedRight !== 0 )\n\t\t{\n\t\t\tthis.s.aoTargets.splice( this.s.aoTargets.length - this.s.fixedRight );\n\t\t}\n\n\t\t/* Disallow columns for being reordered by drag and drop, counting left to right */\n\t\tif ( this.s.fixed !== 0 )\n\t\t{\n\t\t\tthis.s.aoTargets.splice( 0, this.s.fixed );\n\t\t}\n\t},\n\n\n\t/**\n\t * Copy the TH element that is being drags so the user has the idea that they are actually\n\t * moving it around the page.\n\t *  @method  _fnCreateDragNode\n\t *  @returns void\n\t *  @private\n\t */\n\t\"_fnCreateDragNode\": function ()\n\t{\n\t\tvar scrolling = this.s.dt.oScroll.sX !== \"\" || this.s.dt.oScroll.sY !== \"\";\n\n\t\tvar origCell = this.s.dt.aoColumns[ this.s.mouse.targetIndex ].nTh;\n\t\tvar origTr = origCell.parentNode;\n\t\tvar origThead = origTr.parentNode;\n\t\tvar origTable = origThead.parentNode;\n\t\tvar cloneCell = $(origCell).clone();\n\n\t\t// This is a slightly odd combination of jQuery and DOM, but it is the\n\t\t// fastest and least resource intensive way I could think of cloning\n\t\t// the table with just a single header cell in it.\n\t\tthis.dom.drag = $(origTable.cloneNode(false))\n\t\t\t.addClass( 'DTCR_clonedTable' )\n\t\t\t.append(\n\t\t\t\t$(origThead.cloneNode(false)).append(\n\t\t\t\t\t$(origTr.cloneNode(false)).append(\n\t\t\t\t\t\tcloneCell[0]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t.css( {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0,\n\t\t\t\twidth: $(origCell).outerWidth(),\n\t\t\t\theight: $(origCell).outerHeight()\n\t\t\t} )\n\t\t\t.appendTo( 'body' );\n\n\t\tthis.dom.pointer = $('<div></div>')\n\t\t\t.addClass( 'DTCR_pointer' )\n\t\t\t.css( {\n\t\t\t\tposition: 'absolute',\n\t\t\t\ttop: scrolling ?\n\t\t\t\t\t$('div.dataTables_scroll', this.s.dt.nTableWrapper).offset().top :\n\t\t\t\t\t$(this.s.dt.nTable).offset().top,\n\t\t\t\theight : scrolling ?\n\t\t\t\t\t$('div.dataTables_scroll', this.s.dt.nTableWrapper).height() :\n\t\t\t\t\t$(this.s.dt.nTable).height()\n\t\t\t} )\n\t\t\t.appendTo( 'body' );\n\t},\n\n\n\t/**\n\t * Add a data attribute to the column headers, so we know the index of\n\t * the row to be reordered. This allows fast detection of the index, and\n\t * for this plug-in to work with FixedHeader which clones the nodes.\n\t *  @private\n\t */\n\t\"_fnSetColumnIndexes\": function ()\n\t{\n\t\t$.each( this.s.dt.aoColumns, function (i, column) {\n\t\t\t$(column.nTh).attr('data-column-index', i);\n\t\t} );\n\t},\n\n\n\t/**\n\t * Get cursor position regardless of mouse or touch input\n\t * @param  {Event}  e    jQuery Event\n\t * @param  {string} prop Property to get\n\t * @return {number}      Value\n\t */\n\t_fnCursorPosition: function ( e, prop ) {\n\t\tif ( e.type.indexOf('touch') !== -1 ) {\n\t\t\treturn e.originalEvent.touches[0][ prop ];\n\t\t}\n\t\treturn e[ prop ];\n    },\n\n    _fnIsLtr: function () {\n        return $(this.s.dt.nTable).css('direction') !== \"rtl\";\n    }\n} );\n\n\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Static parameters\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n/**\n * ColReorder default settings for initialisation\n *  @namespace\n *  @static\n */\nColReorder.defaults = {\n\t/**\n\t * Predefined ordering for the columns that will be applied automatically\n\t * on initialisation. If not specified then the order that the columns are\n\t * found to be in the HTML is the order used.\n\t *  @type array\n\t *  @default null\n\t *  @static\n\t */\n\taiOrder: null,\n\n\t/**\n\t * ColReorder enable on initialisation\n\t *  @type boolean\n\t *  @default true\n\t *  @static\n\t */\n\tbEnable: true,\n\n\t/**\n\t * Redraw the table's column ordering as the end user draws the column\n\t * (`true`) or wait until the mouse is released (`false` - default). Note\n\t * that this will perform a redraw on each reordering, which involves an\n\t * Ajax request each time if you are using server-side processing in\n\t * DataTables.\n\t *  @type boolean\n\t *  @default false\n\t *  @static\n\t */\n\tbRealtime: true,\n\n\t/**\n\t * Indicate how many columns should be fixed in position (counting from the\n\t * left). This will typically be 1 if used, but can be as high as you like.\n\t *  @type int\n\t *  @default 0\n\t *  @static\n\t */\n\tiFixedColumnsLeft: 0,\n\n\t/**\n\t * As `iFixedColumnsRight` but counting from the right.\n\t *  @type int\n\t *  @default 0\n\t *  @static\n\t */\n\tiFixedColumnsRight: 0,\n\n\t/**\n\t * Callback function that is fired when columns are reordered. The `column-\n\t * reorder` event is preferred over this callback\n\t *  @type function():void\n\t *  @default null\n\t *  @static\n\t */\n\tfnReorderCallback: null\n};\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Constants\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * ColReorder version\n *  @constant  version\n *  @type      String\n *  @default   As code\n */\nColReorder.version = \"1.5.4\";\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables interfaces\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n// Expose\n$.fn.dataTable.ColReorder = ColReorder;\n$.fn.DataTable.ColReorder = ColReorder;\n\n\n// Register a new feature with DataTables\nif ( typeof $.fn.dataTable == \"function\" &&\n     typeof $.fn.dataTableExt.fnVersionCheck == \"function\" &&\n     $.fn.dataTableExt.fnVersionCheck('1.10.8') )\n{\n\t$.fn.dataTableExt.aoFeatures.push( {\n\t\t\"fnInit\": function( settings ) {\n\t\t\tvar table = settings.oInstance;\n\n\t\t\tif ( ! settings._colReorder ) {\n\t\t\t\tvar dtInit = settings.oInit;\n\t\t\t\tvar opts = dtInit.colReorder || dtInit.oColReorder || {};\n\n\t\t\t\tnew ColReorder( settings, opts );\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttable.oApi._fnLog( settings, 1, \"ColReorder attempted to initialise twice. Ignoring second\" );\n\t\t\t}\n\n\t\t\treturn null; /* No node for DataTables to insert */\n\t\t},\n\t\t\"cFeature\": \"R\",\n\t\t\"sFeature\": \"ColReorder\"\n\t} );\n}\nelse {\n\talert( \"Warning: ColReorder requires DataTables 1.10.8 or greater - www.datatables.net/download\");\n}\n\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'preInit.dt.colReorder', function (e, settings) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tvar init = settings.oInit.colReorder;\n\tvar defaults = DataTable.defaults.colReorder;\n\n\tif ( init || defaults ) {\n\t\tvar opts = $.extend( {}, init, defaults );\n\n\t\tif ( init !== false ) {\n\t\t\tnew ColReorder( settings, opts  );\n\t\t}\n\t}\n} );\n\n\n// API augmentation\n$.fn.dataTable.Api.register( 'colReorder.reset()', function () {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tctx._colReorder.fnReset();\n\t} );\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.order()', function ( set, original ) {\n\tif ( set ) {\n\t\treturn this.iterator( 'table', function ( ctx ) {\n\t\t\tctx._colReorder.fnOrder( set, original );\n\t\t} );\n\t}\n\n\treturn this.context.length ?\n\t\tthis.context[0]._colReorder.fnOrder() :\n\t\tnull;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.transpose()', function ( idx, dir ) {\n\treturn this.context.length && this.context[0]._colReorder ?\n\t\tthis.context[0]._colReorder.fnTranspose( idx, dir ) :\n\t\tidx;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.move()', function( from, to, drop, invalidateRows ) {\n\tif (this.context.length) {\n\t\tthis.context[0]._colReorder.s.dt.oInstance.fnColReorder( from, to, drop, invalidateRows );\n\t\tthis.context[0]._colReorder._fnSetColumnIndexes();\n\t}\n\treturn this;\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.enable()', function( flag ) {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._colReorder ) {\n\t\t\tctx._colReorder.fnEnable( flag );\n\t\t}\n\t} );\n} );\n\n$.fn.dataTable.Api.register( 'colReorder.disable()', function() {\n\treturn this.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx._colReorder ) {\n\t\t\tctx._colReorder.fnDisable();\n\t\t}\n\t} );\n} );\n\n\nreturn ColReorder;\n}));\n"]},"metadata":{},"sourceType":"script"}