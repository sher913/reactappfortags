{"ast":null,"code":"/*! Scroller 2.0.4\n * Â©2011-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Scroller\n * @description Virtual rendering for DataTables\n * @version     2.0.4\n * @file        dataTables.scroller.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2011-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['jquery', 'datatables.net'], function ($) {\n      return factory($, window, document);\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = function (root, $) {\n      if (!root) {\n        root = window;\n      }\n\n      if (!$ || !$.fn.dataTable) {\n        $ = require('datatables.net')(root, $).$;\n      }\n\n      return factory($, root, root.document);\n    };\n  } else {\n    // Browser\n    factory(jQuery, window, document);\n  }\n})(function ($, window, document, undefined) {\n  'use strict';\n\n  var DataTable = $.fn.dataTable;\n  /**\n   * Scroller is a virtual rendering plug-in for DataTables which allows large\n   * datasets to be drawn on screen every quickly. What the virtual rendering means\n   * is that only the visible portion of the table (and a bit to either side to make\n   * the scrolling smooth) is drawn, while the scrolling container gives the\n   * visual impression that the whole table is visible. This is done by making use\n   * of the pagination abilities of DataTables and moving the table around in the\n   * scrolling container DataTables adds to the page. The scrolling container is\n   * forced to the height it would be for the full table display using an extra\n   * element.\n   *\n   * Note that rows in the table MUST all be the same height. Information in a cell\n   * which expands on to multiple lines will cause some odd behaviour in the scrolling.\n   *\n   * Scroller is initialised by simply including the letter 'S' in the sDom for the\n   * table you want to have this feature enabled on. Note that the 'S' must come\n   * AFTER the 't' parameter in `dom`.\n   *\n   * Key features include:\n   *   <ul class=\"limit_length\">\n   *     <li>Speed! The aim of Scroller for DataTables is to make rendering large data sets fast</li>\n   *     <li>Full compatibility with deferred rendering in DataTables for maximum speed</li>\n   *     <li>Display millions of rows</li>\n   *     <li>Integration with state saving in DataTables (scrolling position is saved)</li>\n   *     <li>Easy to use</li>\n   *   </ul>\n   *\n   *  @class\n   *  @constructor\n   *  @global\n   *  @param {object} dt DataTables settings object or API instance\n   *  @param {object} [opts={}] Configuration object for Scroller. Options \n   *    are defined by {@link Scroller.defaults}\n   *\n   *  @requires jQuery 1.7+\n   *  @requires DataTables 1.10.0+\n   *\n   *  @example\n   *    $(document).ready(function() {\n   *        $('#example').DataTable( {\n   *            \"scrollY\": \"200px\",\n   *            \"ajax\": \"media/dataset/large.txt\",\n   *            \"scroller\": true,\n   *            \"deferRender\": true\n   *        } );\n   *    } );\n   */\n\n  var Scroller = function (dt, opts) {\n    /* Sanity check - you just know it will happen */\n    if (!(this instanceof Scroller)) {\n      alert(\"Scroller warning: Scroller must be initialised with the 'new' keyword.\");\n      return;\n    }\n\n    if (opts === undefined) {\n      opts = {};\n    }\n\n    var dtApi = $.fn.dataTable.Api(dt);\n    /**\n     * Settings object which contains customisable information for the Scroller instance\n     * @namespace\n     * @private\n     * @extends Scroller.defaults\n     */\n\n    this.s = {\n      /**\n       * DataTables settings object\n       *  @type     object\n       *  @default  Passed in as first parameter to constructor\n       */\n      dt: dtApi.settings()[0],\n\n      /**\n       * DataTables API instance\n       *  @type     DataTable.Api\n       */\n      dtApi: dtApi,\n\n      /**\n       * Pixel location of the top of the drawn table in the viewport\n       *  @type     int\n       *  @default  0\n       */\n      tableTop: 0,\n\n      /**\n       * Pixel location of the bottom of the drawn table in the viewport\n       *  @type     int\n       *  @default  0\n       */\n      tableBottom: 0,\n\n      /**\n       * Pixel location of the boundary for when the next data set should be loaded and drawn\n       * when scrolling up the way.\n       *  @type     int\n       *  @default  0\n       *  @private\n       */\n      redrawTop: 0,\n\n      /**\n       * Pixel location of the boundary for when the next data set should be loaded and drawn\n       * when scrolling down the way. Note that this is actually calculated as the offset from\n       * the top.\n       *  @type     int\n       *  @default  0\n       *  @private\n       */\n      redrawBottom: 0,\n\n      /**\n       * Auto row height or not indicator\n       *  @type     bool\n       *  @default  0\n       */\n      autoHeight: true,\n\n      /**\n       * Number of rows calculated as visible in the visible viewport\n       *  @type     int\n       *  @default  0\n       */\n      viewportRows: 0,\n\n      /**\n       * setTimeout reference for state saving, used when state saving is enabled in the DataTable\n       * and when the user scrolls the viewport in order to stop the cookie set taking too much\n       * CPU!\n       *  @type     int\n       *  @default  0\n       */\n      stateTO: null,\n      stateSaveThrottle: function () {},\n\n      /**\n       * setTimeout reference for the redraw, used when server-side processing is enabled in the\n       * DataTables in order to prevent DoSing the server\n       *  @type     int\n       *  @default  null\n       */\n      drawTO: null,\n      heights: {\n        jump: null,\n        page: null,\n        virtual: null,\n        scroll: null,\n\n        /**\n         * Height of rows in the table\n         *  @type     int\n         *  @default  0\n         */\n        row: null,\n\n        /**\n         * Pixel height of the viewport\n         *  @type     int\n         *  @default  0\n         */\n        viewport: null,\n        labelFactor: 1,\n        labelHeight: 0\n      },\n      topRowFloat: 0,\n      scrollDrawDiff: null,\n      loaderVisible: false,\n      forceReposition: false,\n      baseRowTop: 0,\n      baseScrollTop: 0,\n      mousedown: false,\n      lastScrollTop: 0\n    }; // @todo The defaults should extend a `c` property and the internal settings\n    // only held in the `s` property. At the moment they are mixed\n\n    this.s = $.extend(this.s, Scroller.oDefaults, opts); // Workaround for row height being read from height object (see above comment)\n\n    this.s.heights.row = this.s.rowHeight;\n    /**\n     * DOM elements used by the class instance\n     * @private\n     * @namespace\n     *\n     */\n\n    this.dom = {\n      \"force\": document.createElement('div'),\n      \"label\": $('<div class=\"dts_label\">0</div>'),\n      \"scroller\": null,\n      \"table\": null,\n      \"loader\": null\n    }; // Attach the instance to the DataTables instance so it can be accessed in\n    // future. Don't initialise Scroller twice on the same table\n\n    if (this.s.dt.oScroller) {\n      return;\n    }\n\n    this.s.dt.oScroller = this;\n    /* Let's do it */\n\n    this.construct();\n  };\n\n  $.extend(Scroller.prototype, {\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Public methods - to be exposed via the DataTables API\n     */\n\n    /**\n     * Calculate and store information about how many rows are to be displayed\n     * in the scrolling viewport, based on current dimensions in the browser's\n     * rendering. This can be particularly useful if the table is initially\n     * drawn in a hidden element - for example in a tab.\n     *  @param {bool} [redraw=true] Redraw the table automatically after the recalculation, with\n     *    the new dimensions forming the basis for the draw.\n     *  @returns {void}\n     */\n    measure: function (redraw) {\n      if (this.s.autoHeight) {\n        this._calcRowHeight();\n      }\n\n      var heights = this.s.heights;\n\n      if (heights.row) {\n        heights.viewport = this._parseHeight($(this.dom.scroller).css('max-height'));\n        this.s.viewportRows = parseInt(heights.viewport / heights.row, 10) + 1;\n        this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;\n      }\n\n      var label = this.dom.label.outerHeight();\n      var xbar = this.dom.scroller.offsetHeight - this.dom.scroller.clientHeight;\n      heights.labelHeight = label;\n      heights.labelFactor = (heights.viewport - label - xbar) / heights.scroll;\n\n      if (redraw === undefined || redraw) {\n        this.s.dt.oInstance.fnDraw(false);\n      }\n    },\n\n    /**\n     * Get information about current displayed record range. This corresponds to\n     * the information usually displayed in the \"Info\" block of the table.\n     *\n     * @returns {object} info as an object:\n     *  {\n     *      start: {int}, // the 0-indexed record at the top of the viewport\n     *      end:   {int}, // the 0-indexed record at the bottom of the viewport\n     *  }\n    */\n    pageInfo: function () {\n      var dt = this.s.dt,\n          iScrollTop = this.dom.scroller.scrollTop,\n          iTotal = dt.fnRecordsDisplay(),\n          iPossibleEnd = Math.ceil(this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani));\n      return {\n        start: Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani)),\n        end: iTotal < iPossibleEnd ? iTotal - 1 : iPossibleEnd - 1\n      };\n    },\n\n    /**\n     * Calculate the row number that will be found at the given pixel position\n     * (y-scroll).\n     *\n     * Please note that when the height of the full table exceeds 1 million\n     * pixels, Scroller switches into a non-linear mode for the scrollbar to fit\n     * all of the records into a finite area, but this function returns a linear\n     * value (relative to the last non-linear positioning).\n     *  @param {int} pixels Offset from top to calculate the row number of\n     *  @param {int} [intParse=true] If an integer value should be returned\n     *  @param {int} [virtual=false] Perform the calculations in the virtual domain\n     *  @returns {int} Row index\n     */\n    pixelsToRow: function (pixels, intParse, virtual) {\n      var diff = pixels - this.s.baseScrollTop;\n      var row = virtual ? (this._domain('physicalToVirtual', this.s.baseScrollTop) + diff) / this.s.heights.row : diff / this.s.heights.row + this.s.baseRowTop;\n      return intParse || intParse === undefined ? parseInt(row, 10) : row;\n    },\n\n    /**\n     * Calculate the pixel position from the top of the scrolling container for\n     * a given row\n     *  @param {int} iRow Row number to calculate the position of\n     *  @returns {int} Pixels\n     */\n    rowToPixels: function (rowIdx, intParse, virtual) {\n      var pixels;\n      var diff = rowIdx - this.s.baseRowTop;\n\n      if (virtual) {\n        pixels = this._domain('virtualToPhysical', this.s.baseScrollTop);\n        pixels += diff * this.s.heights.row;\n      } else {\n        pixels = this.s.baseScrollTop;\n        pixels += diff * this.s.heights.row;\n      }\n\n      return intParse || intParse === undefined ? parseInt(pixels, 10) : pixels;\n    },\n\n    /**\n     * Calculate the row number that will be found at the given pixel position (y-scroll)\n     *  @param {int} row Row index to scroll to\n     *  @param {bool} [animate=true] Animate the transition or not\n     *  @returns {void}\n     */\n    scrollToRow: function (row, animate) {\n      var that = this;\n      var ani = false;\n      var px = this.rowToPixels(row); // We need to know if the table will redraw or not before doing the\n      // scroll. If it will not redraw, then we need to use the currently\n      // displayed table, and scroll with the physical pixels. Otherwise, we\n      // need to calculate the table's new position from the virtual\n      // transform.\n\n      var preRows = (this.s.displayBuffer - 1) / 2 * this.s.viewportRows;\n      var drawRow = row - preRows;\n\n      if (drawRow < 0) {\n        drawRow = 0;\n      }\n\n      if ((px > this.s.redrawBottom || px < this.s.redrawTop) && this.s.dt._iDisplayStart !== drawRow) {\n        ani = true;\n        px = this._domain('virtualToPhysical', row * this.s.heights.row); // If we need records outside the current draw region, but the new\n        // scrolling position is inside that (due to the non-linear nature\n        // for larger numbers of records), we need to force position update.\n\n        if (this.s.redrawTop < px && px < this.s.redrawBottom) {\n          this.s.forceReposition = true;\n          animate = false;\n        }\n      }\n\n      if (animate === undefined || animate) {\n        this.s.ani = ani;\n        $(this.dom.scroller).animate({\n          \"scrollTop\": px\n        }, function () {\n          // This needs to happen after the animation has completed and\n          // the final scroll event fired\n          setTimeout(function () {\n            that.s.ani = false;\n          }, 250);\n        });\n      } else {\n        $(this.dom.scroller).scrollTop(px);\n      }\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Constructor\n     */\n\n    /**\n     * Initialisation for Scroller\n     *  @returns {void}\n     *  @private\n     */\n    construct: function () {\n      var that = this;\n      var dt = this.s.dtApi;\n      /* Sanity check */\n\n      if (!this.s.dt.oFeatures.bPaginate) {\n        this.s.dt.oApi._fnLog(this.s.dt, 0, 'Pagination must be enabled for Scroller');\n\n        return;\n      }\n      /* Insert a div element that we can use to force the DT scrolling container to\n       * the height that would be required if the whole table was being displayed\n       */\n\n\n      this.dom.force.style.position = \"relative\";\n      this.dom.force.style.top = \"0px\";\n      this.dom.force.style.left = \"0px\";\n      this.dom.force.style.width = \"1px\";\n      this.dom.scroller = $('div.' + this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];\n      this.dom.scroller.appendChild(this.dom.force);\n      this.dom.scroller.style.position = \"relative\";\n      this.dom.table = $('>table', this.dom.scroller)[0];\n      this.dom.table.style.position = \"absolute\";\n      this.dom.table.style.top = \"0px\";\n      this.dom.table.style.left = \"0px\"; // Add class to 'announce' that we are a Scroller table\n\n      $(dt.table().container()).addClass('dts DTS'); // Add a 'loading' indicator\n\n      if (this.s.loadingIndicator) {\n        this.dom.loader = $('<div class=\"dataTables_processing dts_loading\">' + this.s.dt.oLanguage.sLoadingRecords + '</div>').css('display', 'none');\n        $(this.dom.scroller.parentNode).css('position', 'relative').append(this.dom.loader);\n      }\n\n      this.dom.label.appendTo(this.dom.scroller);\n      /* Initial size calculations */\n\n      if (this.s.heights.row && this.s.heights.row != 'auto') {\n        this.s.autoHeight = false;\n      } // Scrolling callback to see if a page change is needed\n\n\n      this.s.ingnoreScroll = true;\n      $(this.dom.scroller).on('scroll.dt-scroller', function (e) {\n        that._scroll.call(that);\n      }); // In iOS we catch the touchstart event in case the user tries to scroll\n      // while the display is already scrolling\n\n      $(this.dom.scroller).on('touchstart.dt-scroller', function () {\n        that._scroll.call(that);\n      });\n      $(this.dom.scroller).on('mousedown.dt-scroller', function () {\n        that.s.mousedown = true;\n      }).on('mouseup.dt-scroller', function () {\n        that.s.labelVisible = false;\n        that.s.mousedown = false;\n        that.dom.label.css('display', 'none');\n      }); // On resize, update the information element, since the number of rows shown might change\n\n      $(window).on('resize.dt-scroller', function () {\n        that.measure(false);\n\n        that._info();\n      }); // Add a state saving parameter to the DT state saving so we can restore the exact\n      // position of the scrolling.\n\n      var initialStateSave = true;\n      var loadedState = dt.state.loaded();\n      dt.on('stateSaveParams.scroller', function (e, settings, data) {\n        if (initialStateSave && loadedState) {\n          data.scroller = loadedState.scroller;\n          initialStateSave = false;\n        } else {\n          // Need to used the saved position on init\n          data.scroller = {\n            topRow: that.s.topRowFloat,\n            baseScrollTop: that.s.baseScrollTop,\n            baseRowTop: that.s.baseRowTop,\n            scrollTop: that.s.lastScrollTop\n          };\n        }\n      });\n\n      if (loadedState && loadedState.scroller) {\n        this.s.topRowFloat = loadedState.scroller.topRow;\n        this.s.baseScrollTop = loadedState.scroller.baseScrollTop;\n        this.s.baseRowTop = loadedState.scroller.baseRowTop;\n      }\n\n      this.measure(false);\n      that.s.stateSaveThrottle = that.s.dt.oApi._fnThrottle(function () {\n        that.s.dtApi.state.save();\n      }, 500);\n      dt.on('init.scroller', function () {\n        that.measure(false); // Setting to `jump` will instruct _draw to calculate the scroll top\n        // position\n\n        that.s.scrollType = 'jump';\n\n        that._draw(); // Update the scroller when the DataTable is redrawn\n\n\n        dt.on('draw.scroller', function () {\n          that._draw();\n        });\n      }); // Set height before the draw happens, allowing everything else to update\n      // on draw complete without worry for roder.\n\n      dt.on('preDraw.dt.scroller', function () {\n        that._scrollForce();\n      }); // Destructor\n\n      dt.on('destroy.scroller', function () {\n        $(window).off('resize.dt-scroller');\n        $(that.dom.scroller).off('.dt-scroller');\n        $(that.s.dt.nTable).off('.scroller');\n        $(that.s.dt.nTableWrapper).removeClass('DTS');\n        $('div.DTS_Loading', that.dom.scroller.parentNode).remove();\n        that.dom.table.style.position = \"\";\n        that.dom.table.style.top = \"\";\n        that.dom.table.style.left = \"\";\n      });\n    },\n\n    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n     * Private methods\n     */\n\n    /**\n     * Automatic calculation of table row height. This is just a little tricky here as using\n     * initialisation DataTables has tale the table out of the document, so we need to create\n     * a new table and insert it into the document, calculate the row height and then whip the\n     * table out.\n     *  @returns {void}\n     *  @private\n     */\n    _calcRowHeight: function () {\n      var dt = this.s.dt;\n      var origTable = dt.nTable;\n      var nTable = origTable.cloneNode(false);\n      var tbody = $('<tbody/>').appendTo(nTable);\n      var container = $('<div class=\"' + dt.oClasses.sWrapper + ' DTS\">' + '<div class=\"' + dt.oClasses.sScrollWrapper + '\">' + '<div class=\"' + dt.oClasses.sScrollBody + '\"></div>' + '</div>' + '</div>'); // Want 3 rows in the sizing table so :first-child and :last-child\n      // CSS styles don't come into play - take the size of the middle row\n\n      $('tbody tr:lt(4)', origTable).clone().appendTo(tbody);\n      var rowsCount = $('tr', tbody).length;\n\n      if (rowsCount === 1) {\n        tbody.prepend('<tr><td>&#160;</td></tr>');\n        tbody.append('<tr><td>&#160;</td></tr>');\n      } else {\n        for (; rowsCount < 3; rowsCount++) {\n          tbody.append('<tr><td>&#160;</td></tr>');\n        }\n      }\n\n      $('div.' + dt.oClasses.sScrollBody, container).append(nTable); // If initialised using `dom`, use the holding element as the insert point\n\n      var insertEl = this.s.dt.nHolding || origTable.parentNode;\n\n      if (!$(insertEl).is(':visible')) {\n        insertEl = 'body';\n      } // Remove form element links as they might select over others (particularly radio and checkboxes)\n\n\n      container.find(\"input\").removeAttr(\"name\");\n      container.appendTo(insertEl);\n      this.s.heights.row = $('tr', tbody).eq(1).outerHeight();\n      container.remove();\n    },\n\n    /**\n     * Draw callback function which is fired when the DataTable is redrawn. The main function of\n     * this method is to position the drawn table correctly the scrolling container for the rows\n     * that is displays as a result of the scrolling position.\n     *  @returns {void}\n     *  @private\n     */\n    _draw: function () {\n      var that = this,\n          heights = this.s.heights,\n          iScrollTop = this.dom.scroller.scrollTop,\n          iTableHeight = $(this.s.dt.nTable).height(),\n          displayStart = this.s.dt._iDisplayStart,\n          displayLen = this.s.dt._iDisplayLength,\n          displayEnd = this.s.dt.fnRecordsDisplay(); // Disable the scroll event listener while we are updating the DOM\n\n      this.s.skip = true; // If paging is reset\n\n      if ((this.s.dt.bSorted || this.s.dt.bFiltered) && displayStart === 0 && !this.s.dt._drawHold) {\n        this.s.topRowFloat = 0;\n      }\n\n      iScrollTop = this.s.scrollType === 'jump' ? this._domain('virtualToPhysical', this.s.topRowFloat * heights.row) : iScrollTop; // Store positional information so positional calculations can be based\n      // upon the current table draw position\n\n      this.s.baseScrollTop = iScrollTop;\n      this.s.baseRowTop = this.s.topRowFloat; // Position the table in the virtual scroller\n\n      var tableTop = iScrollTop - (this.s.topRowFloat - displayStart) * heights.row;\n\n      if (displayStart === 0) {\n        tableTop = 0;\n      } else if (displayStart + displayLen >= displayEnd) {\n        tableTop = heights.scroll - iTableHeight;\n      }\n\n      this.dom.table.style.top = tableTop + 'px';\n      /* Cache some information for the scroller */\n\n      this.s.tableTop = tableTop;\n      this.s.tableBottom = iTableHeight + this.s.tableTop; // Calculate the boundaries for where a redraw will be triggered by the\n      // scroll event listener\n\n      var boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;\n      this.s.redrawTop = iScrollTop - boundaryPx;\n      this.s.redrawBottom = iScrollTop + boundaryPx > heights.scroll - heights.viewport - heights.row ? heights.scroll - heights.viewport - heights.row : iScrollTop + boundaryPx;\n      this.s.skip = false; // Restore the scrolling position that was saved by DataTable's state\n      // saving Note that this is done on the second draw when data is Ajax\n      // sourced, and the first draw when DOM soured\n\n      if (this.s.dt.oFeatures.bStateSave && this.s.dt.oLoadedState !== null && typeof this.s.dt.oLoadedState.scroller != 'undefined') {\n        // A quirk of DataTables is that the draw callback will occur on an\n        // empty set if Ajax sourced, but not if server-side processing.\n        var ajaxSourced = (this.s.dt.sAjaxSource || that.s.dt.ajax) && !this.s.dt.oFeatures.bServerSide ? true : false;\n\n        if (ajaxSourced && this.s.dt.iDraw == 2 || !ajaxSourced && this.s.dt.iDraw == 1) {\n          setTimeout(function () {\n            $(that.dom.scroller).scrollTop(that.s.dt.oLoadedState.scroller.scrollTop); // In order to prevent layout thrashing we need another\n            // small delay\n\n            setTimeout(function () {\n              that.s.ingnoreScroll = false;\n            }, 0);\n          }, 0);\n        }\n      } else {\n        that.s.ingnoreScroll = false;\n      } // Because of the order of the DT callbacks, the info update will\n      // take precedence over the one we want here. So a 'thread' break is\n      // needed.  Only add the thread break if bInfo is set\n\n\n      if (this.s.dt.oFeatures.bInfo) {\n        setTimeout(function () {\n          that._info.call(that);\n        }, 0);\n      }\n\n      $(this.s.dt.nTable).triggerHandler('position.dts.dt', tableTop); // Hide the loading indicator\n\n      if (this.dom.loader && this.s.loaderVisible) {\n        this.dom.loader.css('display', 'none');\n        this.s.loaderVisible = false;\n      }\n    },\n\n    /**\n     * Convert from one domain to another. The physical domain is the actual\n     * pixel count on the screen, while the virtual is if we had browsers which\n     * had scrolling containers of infinite height (i.e. the absolute value)\n     *\n     *  @param {string} dir Domain transform direction, `virtualToPhysical` or\n     *    `physicalToVirtual` \n     *  @returns {number} Calculated transform\n     *  @private\n     */\n    _domain: function (dir, val) {\n      var heights = this.s.heights;\n      var diff;\n      var magic = 10000; // the point at which the non-linear calculations start to happen\n      // If the virtual and physical height match, then we use a linear\n      // transform between the two, allowing the scrollbar to be linear\n\n      if (heights.virtual === heights.scroll) {\n        return val;\n      } // In the first 10k pixels and the last 10k pixels, we want the scrolling\n      // to be linear. After that it can be non-linear. It would be unusual for\n      // anyone to mouse wheel through that much.\n\n\n      if (val < magic) {\n        return val;\n      } else if (dir === 'virtualToPhysical' && val >= heights.virtual - magic) {\n        diff = heights.virtual - val;\n        return heights.scroll - diff;\n      } else if (dir === 'physicalToVirtual' && val >= heights.scroll - magic) {\n        diff = heights.scroll - val;\n        return heights.virtual - diff;\n      } // Otherwise, we want a non-linear scrollbar to take account of the\n      // redrawing regions at the start and end of the table, otherwise these\n      // can stutter badly - on large tables 30px (for example) scroll might\n      // be hundreds of rows, so the table would be redrawing every few px at\n      // the start and end. Use a simple linear eq. to stop this, effectively\n      // causing a kink in the scrolling ratio. It does mean the scrollbar is\n      // non-linear, but with such massive data sets, the scrollbar is going\n      // to be a best guess anyway\n\n\n      var m = (heights.virtual - magic - magic) / (heights.scroll - magic - magic);\n      var c = magic - m * magic;\n      return dir === 'virtualToPhysical' ? (val - c) / m : m * val + c;\n    },\n\n    /**\n     * Update any information elements that are controlled by the DataTable based on the scrolling\n     * viewport and what rows are visible in it. This function basically acts in the same way as\n     * _fnUpdateInfo in DataTables, and effectively replaces that function.\n     *  @returns {void}\n     *  @private\n     */\n    _info: function () {\n      if (!this.s.dt.oFeatures.bInfo) {\n        return;\n      }\n\n      var dt = this.s.dt,\n          language = dt.oLanguage,\n          iScrollTop = this.dom.scroller.scrollTop,\n          iStart = Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani) + 1),\n          iMax = dt.fnRecordsTotal(),\n          iTotal = dt.fnRecordsDisplay(),\n          iPossibleEnd = Math.ceil(this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani)),\n          iEnd = iTotal < iPossibleEnd ? iTotal : iPossibleEnd,\n          sStart = dt.fnFormatNumber(iStart),\n          sEnd = dt.fnFormatNumber(iEnd),\n          sMax = dt.fnFormatNumber(iMax),\n          sTotal = dt.fnFormatNumber(iTotal),\n          sOut;\n\n      if (dt.fnRecordsDisplay() === 0 && dt.fnRecordsDisplay() == dt.fnRecordsTotal()) {\n        /* Empty record set */\n        sOut = language.sInfoEmpty + language.sInfoPostFix;\n      } else if (dt.fnRecordsDisplay() === 0) {\n        /* Empty record set after filtering */\n        sOut = language.sInfoEmpty + ' ' + language.sInfoFiltered.replace('_MAX_', sMax) + language.sInfoPostFix;\n      } else if (dt.fnRecordsDisplay() == dt.fnRecordsTotal()) {\n        /* Normal record set */\n        sOut = language.sInfo.replace('_START_', sStart).replace('_END_', sEnd).replace('_MAX_', sMax).replace('_TOTAL_', sTotal) + language.sInfoPostFix;\n      } else {\n        /* Record set after filtering */\n        sOut = language.sInfo.replace('_START_', sStart).replace('_END_', sEnd).replace('_MAX_', sMax).replace('_TOTAL_', sTotal) + ' ' + language.sInfoFiltered.replace('_MAX_', dt.fnFormatNumber(dt.fnRecordsTotal())) + language.sInfoPostFix;\n      }\n\n      var callback = language.fnInfoCallback;\n\n      if (callback) {\n        sOut = callback.call(dt.oInstance, dt, iStart, iEnd, iMax, iTotal, sOut);\n      }\n\n      var n = dt.aanFeatures.i;\n\n      if (typeof n != 'undefined') {\n        for (var i = 0, iLen = n.length; i < iLen; i++) {\n          $(n[i]).html(sOut);\n        }\n      } // DT doesn't actually (yet) trigger this event, but it will in future\n\n\n      $(dt.nTable).triggerHandler('info.dt');\n    },\n\n    /**\n     * Parse CSS height property string as number\n     *\n     * An attempt is made to parse the string as a number. Currently supported units are 'px',\n     * 'vh', and 'rem'. 'em' is partially supported; it works as long as the parent element's\n     * font size matches the body element. Zero is returned for unrecognized strings.\n     *  @param {string} cssHeight CSS height property string\n     *  @returns {number} height\n     *  @private\n     */\n    _parseHeight: function (cssHeight) {\n      var height;\n      var matches = /^([+-]?(?:\\d+(?:\\.\\d+)?|\\.\\d+))(px|em|rem|vh)$/.exec(cssHeight);\n\n      if (matches === null) {\n        return 0;\n      }\n\n      var value = parseFloat(matches[1]);\n      var unit = matches[2];\n\n      if (unit === 'px') {\n        height = value;\n      } else if (unit === 'vh') {\n        height = value / 100 * $(window).height();\n      } else if (unit === 'rem') {\n        height = value * parseFloat($(':root').css('font-size'));\n      } else if (unit === 'em') {\n        height = value * parseFloat($('body').css('font-size'));\n      }\n\n      return height ? height : 0;\n    },\n\n    /**\n     * Scrolling function - fired whenever the scrolling position is changed.\n     * This method needs to use the stored values to see if the table should be\n     * redrawn as we are moving towards the end of the information that is\n     * currently drawn or not. If needed, then it will redraw the table based on\n     * the new position.\n     *  @returns {void}\n     *  @private\n     */\n    _scroll: function () {\n      var that = this,\n          heights = this.s.heights,\n          iScrollTop = this.dom.scroller.scrollTop,\n          iTopRow;\n\n      if (this.s.skip) {\n        return;\n      }\n\n      if (this.s.ingnoreScroll) {\n        return;\n      }\n\n      if (iScrollTop === this.s.lastScrollTop) {\n        return;\n      }\n      /* If the table has been sorted or filtered, then we use the redraw that\n       * DataTables as done, rather than performing our own\n       */\n\n\n      if (this.s.dt.bFiltered || this.s.dt.bSorted) {\n        this.s.lastScrollTop = 0;\n        return;\n      }\n      /* Update the table's information display for what is now in the viewport */\n\n\n      this._info();\n      /* We don't want to state save on every scroll event - that's heavy\n       * handed, so use a timeout to update the state saving only when the\n       * scrolling has finished\n       */\n\n\n      clearTimeout(this.s.stateTO);\n      this.s.stateTO = setTimeout(function () {\n        that.s.dtApi.state.save();\n      }, 250);\n      this.s.scrollType = Math.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport ? 'jump' : 'cont';\n      this.s.topRowFloat = this.s.scrollType === 'cont' ? this.pixelsToRow(iScrollTop, false, false) : this._domain('physicalToVirtual', iScrollTop) / heights.row;\n\n      if (this.s.topRowFloat < 0) {\n        this.s.topRowFloat = 0;\n      }\n      /* Check if the scroll point is outside the trigger boundary which would required\n       * a DataTables redraw\n       */\n\n\n      if (this.s.forceReposition || iScrollTop < this.s.redrawTop || iScrollTop > this.s.redrawBottom) {\n        var preRows = Math.ceil((this.s.displayBuffer - 1) / 2 * this.s.viewportRows);\n        iTopRow = parseInt(this.s.topRowFloat, 10) - preRows;\n        this.s.forceReposition = false;\n\n        if (iTopRow <= 0) {\n          /* At the start of the table */\n          iTopRow = 0;\n        } else if (iTopRow + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay()) {\n          /* At the end of the table */\n          iTopRow = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;\n\n          if (iTopRow < 0) {\n            iTopRow = 0;\n          }\n        } else if (iTopRow % 2 !== 0) {\n          // For the row-striping classes (odd/even) we want only to start\n          // on evens otherwise the stripes will change between draws and\n          // look rubbish\n          iTopRow++;\n        } // Store calcuated value, in case the following condition is not met, but so\n        // that the draw function will still use it.\n\n\n        this.s.targetTop = iTopRow;\n\n        if (iTopRow != this.s.dt._iDisplayStart) {\n          /* Cache the new table position for quick lookups */\n          this.s.tableTop = $(this.s.dt.nTable).offset().top;\n          this.s.tableBottom = $(this.s.dt.nTable).height() + this.s.tableTop;\n\n          var draw = function () {\n            that.s.dt._iDisplayStart = that.s.targetTop;\n\n            that.s.dt.oApi._fnDraw(that.s.dt);\n          };\n          /* Do the DataTables redraw based on the calculated start point - note that when\n           * using server-side processing we introduce a small delay to not DoS the server...\n           */\n\n\n          if (this.s.dt.oFeatures.bServerSide) {\n            this.s.forceReposition = true;\n            clearTimeout(this.s.drawTO);\n            this.s.drawTO = setTimeout(draw, this.s.serverWait);\n          } else {\n            draw();\n          }\n\n          if (this.dom.loader && !this.s.loaderVisible) {\n            this.dom.loader.css('display', 'block');\n            this.s.loaderVisible = true;\n          }\n        }\n      } else {\n        this.s.topRowFloat = this.pixelsToRow(iScrollTop, false, true);\n      }\n\n      this.s.lastScrollTop = iScrollTop;\n      this.s.stateSaveThrottle();\n\n      if (this.s.scrollType === 'jump' && this.s.mousedown) {\n        this.s.labelVisible = true;\n      }\n\n      if (this.s.labelVisible) {\n        this.dom.label.html(this.s.dt.fnFormatNumber(parseInt(this.s.topRowFloat, 10) + 1)).css('top', iScrollTop + iScrollTop * heights.labelFactor).css('display', 'block');\n      }\n    },\n\n    /**\n     * Force the scrolling container to have height beyond that of just the\n     * table that has been drawn so the user can scroll the whole data set.\n     *\n     * Note that if the calculated required scrolling height exceeds a maximum\n     * value (1 million pixels - hard-coded) the forcing element will be set\n     * only to that maximum value and virtual / physical domain transforms will\n     * be used to allow Scroller to display tables of any number of records.\n     *  @returns {void}\n     *  @private\n     */\n    _scrollForce: function () {\n      var heights = this.s.heights;\n      var max = 1000000;\n      heights.virtual = heights.row * this.s.dt.fnRecordsDisplay();\n      heights.scroll = heights.virtual;\n\n      if (heights.scroll > max) {\n        heights.scroll = max;\n      } // Minimum height so there is always a row visible (the 'no rows found'\n      // if reduced to zero filtering)\n\n\n      this.dom.force.style.height = heights.scroll > this.s.heights.row ? heights.scroll + 'px' : this.s.heights.row + 'px';\n    }\n  });\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Statics\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * Scroller default settings for initialisation\n   *  @namespace\n   *  @name Scroller.defaults\n   *  @static\n   */\n\n  Scroller.defaults = {\n    /**\n     * Scroller uses the boundary scaling factor to decide when to redraw the table - which it\n     * typically does before you reach the end of the currently loaded data set (in order to\n     * allow the data to look continuous to a user scrolling through the data). If given as 0\n     * then the table will be redrawn whenever the viewport is scrolled, while 1 would not\n     * redraw the table until the currently loaded data has all been shown. You will want\n     * something in the middle - the default factor of 0.5 is usually suitable.\n     *  @type     float\n     *  @default  0.5\n     *  @static\n     */\n    boundaryScale: 0.5,\n\n    /**\n     * The display buffer is what Scroller uses to calculate how many rows it should pre-fetch\n     * for scrolling. Scroller automatically adjusts DataTables' display length to pre-fetch\n     * rows that will be shown in \"near scrolling\" (i.e. just beyond the current display area).\n     * The value is based upon the number of rows that can be displayed in the viewport (i.e.\n     * a value of 1), and will apply the display range to records before before and after the\n     * current viewport - i.e. a factor of 3 will allow Scroller to pre-fetch 1 viewport's worth\n     * of rows before the current viewport, the current viewport's rows and 1 viewport's worth\n     * of rows after the current viewport. Adjusting this value can be useful for ensuring\n     * smooth scrolling based on your data set.\n     *  @type     int\n     *  @default  7\n     *  @static\n     */\n    displayBuffer: 9,\n\n    /**\n     * Show (or not) the loading element in the background of the table. Note that you should\n     * include the dataTables.scroller.css file for this to be displayed correctly.\n     *  @type     boolean\n     *  @default  false\n     *  @static\n     */\n    loadingIndicator: false,\n\n    /**\n     * Scroller will attempt to automatically calculate the height of rows for it's internal\n     * calculations. However the height that is used can be overridden using this parameter.\n     *  @type     int|string\n     *  @default  auto\n     *  @static\n     */\n    rowHeight: \"auto\",\n\n    /**\n     * When using server-side processing, Scroller will wait a small amount of time to allow\n     * the scrolling to finish before requesting more data from the server. This prevents\n     * you from DoSing your own server! The wait time can be configured by this parameter.\n     *  @type     int\n     *  @default  200\n     *  @static\n     */\n    serverWait: 200\n  };\n  Scroller.oDefaults = Scroller.defaults;\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Constants\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n  /**\n   * Scroller version\n   *  @type      String\n   *  @default   See code\n   *  @name      Scroller.version\n   *  @static\n   */\n\n  Scroller.version = \"2.0.4\";\n  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n   * Initialisation\n   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n  // Attach a listener to the document which listens for DataTables initialisation\n  // events so we can automatically initialise\n\n  $(document).on('preInit.dt.dtscroller', function (e, settings) {\n    if (e.namespace !== 'dt') {\n      return;\n    }\n\n    var init = settings.oInit.scroller;\n    var defaults = DataTable.defaults.scroller;\n\n    if (init || defaults) {\n      var opts = $.extend({}, init, defaults);\n\n      if (init !== false) {\n        new Scroller(settings, opts);\n      }\n    }\n  }); // Attach Scroller to DataTables so it can be accessed as an 'extra'\n\n  $.fn.dataTable.Scroller = Scroller;\n  $.fn.DataTable.Scroller = Scroller; // DataTables 1.10 API method aliases\n\n  var Api = $.fn.dataTable.Api;\n  Api.register('scroller()', function () {\n    return this;\n  }); // Undocumented and deprecated - is it actually useful at all?\n\n  Api.register('scroller().rowToPixels()', function (rowIdx, intParse, virtual) {\n    var ctx = this.context;\n\n    if (ctx.length && ctx[0].oScroller) {\n      return ctx[0].oScroller.rowToPixels(rowIdx, intParse, virtual);\n    } // undefined\n\n  }); // Undocumented and deprecated - is it actually useful at all?\n\n  Api.register('scroller().pixelsToRow()', function (pixels, intParse, virtual) {\n    var ctx = this.context;\n\n    if (ctx.length && ctx[0].oScroller) {\n      return ctx[0].oScroller.pixelsToRow(pixels, intParse, virtual);\n    } // undefined\n\n  }); // `scroller().scrollToRow()` is undocumented and deprecated. Use `scroller.toPosition()\n\n  Api.register(['scroller().scrollToRow()', 'scroller.toPosition()'], function (idx, ani) {\n    this.iterator('table', function (ctx) {\n      if (ctx.oScroller) {\n        ctx.oScroller.scrollToRow(idx, ani);\n      }\n    });\n    return this;\n  });\n  Api.register('row().scrollTo()', function (ani) {\n    var that = this;\n    this.iterator('row', function (ctx, rowIdx) {\n      if (ctx.oScroller) {\n        var displayIdx = that.rows({\n          order: 'applied',\n          search: 'applied'\n        }).indexes().indexOf(rowIdx);\n        ctx.oScroller.scrollToRow(displayIdx, ani);\n      }\n    });\n    return this;\n  });\n  Api.register('scroller.measure()', function (redraw) {\n    this.iterator('table', function (ctx) {\n      if (ctx.oScroller) {\n        ctx.oScroller.measure(redraw);\n      }\n    });\n    return this;\n  });\n  Api.register('scroller.page()', function () {\n    var ctx = this.context;\n\n    if (ctx.length && ctx[0].oScroller) {\n      return ctx[0].oScroller.pageInfo();\n    } // undefined\n\n  });\n  return Scroller;\n});","map":{"version":3,"sources":["C:/Users/Sher/Desktop/datahub tagging ui/frontend/node_modules/datatables.net-scroller/js/dataTables.scroller.js"],"names":["factory","define","amd","$","window","document","exports","module","root","fn","dataTable","require","jQuery","undefined","DataTable","Scroller","dt","opts","alert","dtApi","Api","s","settings","tableTop","tableBottom","redrawTop","redrawBottom","autoHeight","viewportRows","stateTO","stateSaveThrottle","drawTO","heights","jump","page","virtual","scroll","row","viewport","labelFactor","labelHeight","topRowFloat","scrollDrawDiff","loaderVisible","forceReposition","baseRowTop","baseScrollTop","mousedown","lastScrollTop","extend","oDefaults","rowHeight","dom","createElement","oScroller","construct","prototype","measure","redraw","_calcRowHeight","_parseHeight","scroller","css","parseInt","_iDisplayLength","displayBuffer","label","outerHeight","xbar","offsetHeight","clientHeight","oInstance","fnDraw","pageInfo","iScrollTop","scrollTop","iTotal","fnRecordsDisplay","iPossibleEnd","Math","ceil","pixelsToRow","ani","start","floor","end","pixels","intParse","diff","_domain","rowToPixels","rowIdx","scrollToRow","animate","that","px","preRows","drawRow","_iDisplayStart","setTimeout","oFeatures","bPaginate","oApi","_fnLog","force","style","position","top","left","width","oClasses","sScrollBody","nTableWrapper","appendChild","table","container","addClass","loadingIndicator","loader","oLanguage","sLoadingRecords","parentNode","append","appendTo","ingnoreScroll","on","e","_scroll","call","labelVisible","_info","initialStateSave","loadedState","state","loaded","data","topRow","_fnThrottle","save","scrollType","_draw","_scrollForce","off","nTable","removeClass","remove","origTable","cloneNode","tbody","sWrapper","sScrollWrapper","clone","rowsCount","length","prepend","insertEl","nHolding","is","find","removeAttr","eq","iTableHeight","height","displayStart","displayLen","displayEnd","skip","bSorted","bFiltered","_drawHold","boundaryPx","boundaryScale","bStateSave","oLoadedState","ajaxSourced","sAjaxSource","ajax","bServerSide","iDraw","bInfo","triggerHandler","dir","val","magic","m","c","language","iStart","iMax","fnRecordsTotal","iEnd","sStart","fnFormatNumber","sEnd","sMax","sTotal","sOut","sInfoEmpty","sInfoPostFix","sInfoFiltered","replace","sInfo","callback","fnInfoCallback","n","aanFeatures","i","iLen","html","cssHeight","matches","exec","value","parseFloat","unit","iTopRow","clearTimeout","abs","targetTop","offset","draw","_fnDraw","serverWait","max","defaults","version","namespace","init","oInit","register","ctx","context","idx","iterator","displayIdx","rows","order","search","indexes","indexOf"],"mappings":"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","sourcesContent":["/*! Scroller 2.0.4\n * Â©2011-2021 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Scroller\n * @description Virtual rendering for DataTables\n * @version     2.0.4\n * @file        dataTables.scroller.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2011-2021 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n(function( factory ){\n\tif ( typeof define === 'function' && define.amd ) {\n\t\t// AMD\n\t\tdefine( ['jquery', 'datatables.net'], function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t} );\n\t}\n\telse if ( typeof exports === 'object' ) {\n\t\t// CommonJS\n\t\tmodule.exports = function (root, $) {\n\t\t\tif ( ! root ) {\n\t\t\t\troot = window;\n\t\t\t}\n\n\t\t\tif ( ! $ || ! $.fn.dataTable ) {\n\t\t\t\t$ = require('datatables.net')(root, $).$;\n\t\t\t}\n\n\t\t\treturn factory( $, root, root.document );\n\t\t};\n\t}\n\telse {\n\t\t// Browser\n\t\tfactory( jQuery, window, document );\n\t}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/**\n * Scroller is a virtual rendering plug-in for DataTables which allows large\n * datasets to be drawn on screen every quickly. What the virtual rendering means\n * is that only the visible portion of the table (and a bit to either side to make\n * the scrolling smooth) is drawn, while the scrolling container gives the\n * visual impression that the whole table is visible. This is done by making use\n * of the pagination abilities of DataTables and moving the table around in the\n * scrolling container DataTables adds to the page. The scrolling container is\n * forced to the height it would be for the full table display using an extra\n * element.\n *\n * Note that rows in the table MUST all be the same height. Information in a cell\n * which expands on to multiple lines will cause some odd behaviour in the scrolling.\n *\n * Scroller is initialised by simply including the letter 'S' in the sDom for the\n * table you want to have this feature enabled on. Note that the 'S' must come\n * AFTER the 't' parameter in `dom`.\n *\n * Key features include:\n *   <ul class=\"limit_length\">\n *     <li>Speed! The aim of Scroller for DataTables is to make rendering large data sets fast</li>\n *     <li>Full compatibility with deferred rendering in DataTables for maximum speed</li>\n *     <li>Display millions of rows</li>\n *     <li>Integration with state saving in DataTables (scrolling position is saved)</li>\n *     <li>Easy to use</li>\n *   </ul>\n *\n *  @class\n *  @constructor\n *  @global\n *  @param {object} dt DataTables settings object or API instance\n *  @param {object} [opts={}] Configuration object for Scroller. Options \n *    are defined by {@link Scroller.defaults}\n *\n *  @requires jQuery 1.7+\n *  @requires DataTables 1.10.0+\n *\n *  @example\n *    $(document).ready(function() {\n *        $('#example').DataTable( {\n *            \"scrollY\": \"200px\",\n *            \"ajax\": \"media/dataset/large.txt\",\n *            \"scroller\": true,\n *            \"deferRender\": true\n *        } );\n *    } );\n */\nvar Scroller = function ( dt, opts ) {\n\t/* Sanity check - you just know it will happen */\n\tif ( ! (this instanceof Scroller) ) {\n\t\talert( \"Scroller warning: Scroller must be initialised with the 'new' keyword.\" );\n\t\treturn;\n\t}\n\n\tif ( opts === undefined ) {\n\t\topts = {};\n\t}\n\n\tvar dtApi = $.fn.dataTable.Api( dt );\n\n\t/**\n\t * Settings object which contains customisable information for the Scroller instance\n\t * @namespace\n\t * @private\n\t * @extends Scroller.defaults\n\t */\n\tthis.s = {\n\t\t/**\n\t\t * DataTables settings object\n\t\t *  @type     object\n\t\t *  @default  Passed in as first parameter to constructor\n\t\t */\n\t\tdt: dtApi.settings()[0],\n\n\t\t/**\n\t\t * DataTables API instance\n\t\t *  @type     DataTable.Api\n\t\t */\n\t\tdtApi: dtApi,\n\n\t\t/**\n\t\t * Pixel location of the top of the drawn table in the viewport\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\ttableTop: 0,\n\n\t\t/**\n\t\t * Pixel location of the bottom of the drawn table in the viewport\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\ttableBottom: 0,\n\n\t\t/**\n\t\t * Pixel location of the boundary for when the next data set should be loaded and drawn\n\t\t * when scrolling up the way.\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t *  @private\n\t\t */\n\t\tredrawTop: 0,\n\n\t\t/**\n\t\t * Pixel location of the boundary for when the next data set should be loaded and drawn\n\t\t * when scrolling down the way. Note that this is actually calculated as the offset from\n\t\t * the top.\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t *  @private\n\t\t */\n\t\tredrawBottom: 0,\n\n\t\t/**\n\t\t * Auto row height or not indicator\n\t\t *  @type     bool\n\t\t *  @default  0\n\t\t */\n\t\tautoHeight: true,\n\n\t\t/**\n\t\t * Number of rows calculated as visible in the visible viewport\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\tviewportRows: 0,\n\n\t\t/**\n\t\t * setTimeout reference for state saving, used when state saving is enabled in the DataTable\n\t\t * and when the user scrolls the viewport in order to stop the cookie set taking too much\n\t\t * CPU!\n\t\t *  @type     int\n\t\t *  @default  0\n\t\t */\n\t\tstateTO: null,\n\n\t\tstateSaveThrottle: function () {},\n\n\t\t/**\n\t\t * setTimeout reference for the redraw, used when server-side processing is enabled in the\n\t\t * DataTables in order to prevent DoSing the server\n\t\t *  @type     int\n\t\t *  @default  null\n\t\t */\n\t\tdrawTO: null,\n\n\t\theights: {\n\t\t\tjump: null,\n\t\t\tpage: null,\n\t\t\tvirtual: null,\n\t\t\tscroll: null,\n\n\t\t\t/**\n\t\t\t * Height of rows in the table\n\t\t\t *  @type     int\n\t\t\t *  @default  0\n\t\t\t */\n\t\t\trow: null,\n\n\t\t\t/**\n\t\t\t * Pixel height of the viewport\n\t\t\t *  @type     int\n\t\t\t *  @default  0\n\t\t\t */\n\t\t\tviewport: null,\n\t\t\tlabelFactor: 1,\n\t\t\tlabelHeight: 0,\n\t\t},\n\n\t\ttopRowFloat: 0,\n\t\tscrollDrawDiff: null,\n\t\tloaderVisible: false,\n\t\tforceReposition: false,\n\t\tbaseRowTop: 0,\n\t\tbaseScrollTop: 0,\n\t\tmousedown: false,\n\t\tlastScrollTop: 0\n\t};\n\n\t// @todo The defaults should extend a `c` property and the internal settings\n\t// only held in the `s` property. At the moment they are mixed\n\tthis.s = $.extend( this.s, Scroller.oDefaults, opts );\n\n\t// Workaround for row height being read from height object (see above comment)\n\tthis.s.heights.row = this.s.rowHeight;\n\n\t/**\n\t * DOM elements used by the class instance\n\t * @private\n\t * @namespace\n\t *\n\t */\n\tthis.dom = {\n\t\t\"force\":    document.createElement('div'),\n\t\t\"label\":    $('<div class=\"dts_label\">0</div>'),\n\t\t\"scroller\": null,\n\t\t\"table\":    null,\n\t\t\"loader\":   null\n\t};\n\n\t// Attach the instance to the DataTables instance so it can be accessed in\n\t// future. Don't initialise Scroller twice on the same table\n\tif ( this.s.dt.oScroller ) {\n\t\treturn;\n\t}\n\n\tthis.s.dt.oScroller = this;\n\n\t/* Let's do it */\n\tthis.construct();\n};\n\n\n\n$.extend( Scroller.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods - to be exposed via the DataTables API\n\t */\n\n\t/**\n\t * Calculate and store information about how many rows are to be displayed\n\t * in the scrolling viewport, based on current dimensions in the browser's\n\t * rendering. This can be particularly useful if the table is initially\n\t * drawn in a hidden element - for example in a tab.\n\t *  @param {bool} [redraw=true] Redraw the table automatically after the recalculation, with\n\t *    the new dimensions forming the basis for the draw.\n\t *  @returns {void}\n\t */\n\tmeasure: function ( redraw )\n\t{\n\t\tif ( this.s.autoHeight )\n\t\t{\n\t\t\tthis._calcRowHeight();\n\t\t}\n\n\t\tvar heights = this.s.heights;\n\n\t\tif ( heights.row ) {\n\t\t\theights.viewport = this._parseHeight($(this.dom.scroller).css('max-height'));\n\n\t\t\tthis.s.viewportRows = parseInt( heights.viewport / heights.row, 10 )+1;\n\t\t\tthis.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer;\n\t\t}\n\n\t\tvar label = this.dom.label.outerHeight();\n\t\tvar xbar = this.dom.scroller.offsetHeight - this.dom.scroller.clientHeight;\n\t\theights.labelHeight = label;\n\t\theights.labelFactor = (heights.viewport-label - xbar) / heights.scroll;\n\n\t\tif ( redraw === undefined || redraw )\n\t\t{\n\t\t\tthis.s.dt.oInstance.fnDraw( false );\n\t\t}\n\t},\n\n\t/**\n\t * Get information about current displayed record range. This corresponds to\n\t * the information usually displayed in the \"Info\" block of the table.\n\t *\n\t * @returns {object} info as an object:\n\t *  {\n\t *      start: {int}, // the 0-indexed record at the top of the viewport\n\t *      end:   {int}, // the 0-indexed record at the bottom of the viewport\n\t *  }\n\t*/\n\tpageInfo: function()\n\t{\n\t\tvar \n\t\t\tdt = this.s.dt,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiTotal = dt.fnRecordsDisplay(),\n\t\t\tiPossibleEnd = Math.ceil(this.pixelsToRow(iScrollTop + this.s.heights.viewport, false, this.s.ani));\n\n\t\treturn {\n\t\t\tstart: Math.floor(this.pixelsToRow(iScrollTop, false, this.s.ani)),\n\t\t\tend: iTotal < iPossibleEnd ? iTotal-1 : iPossibleEnd-1\n\t\t};\n\t},\n\n\t/**\n\t * Calculate the row number that will be found at the given pixel position\n\t * (y-scroll).\n\t *\n\t * Please note that when the height of the full table exceeds 1 million\n\t * pixels, Scroller switches into a non-linear mode for the scrollbar to fit\n\t * all of the records into a finite area, but this function returns a linear\n\t * value (relative to the last non-linear positioning).\n\t *  @param {int} pixels Offset from top to calculate the row number of\n\t *  @param {int} [intParse=true] If an integer value should be returned\n\t *  @param {int} [virtual=false] Perform the calculations in the virtual domain\n\t *  @returns {int} Row index\n\t */\n\tpixelsToRow: function ( pixels, intParse, virtual )\n\t{\n\t\tvar diff = pixels - this.s.baseScrollTop;\n\t\tvar row = virtual ?\n\t\t\t(this._domain( 'physicalToVirtual', this.s.baseScrollTop ) + diff) / this.s.heights.row :\n\t\t\t( diff / this.s.heights.row ) + this.s.baseRowTop;\n\n\t\treturn intParse || intParse === undefined ?\n\t\t\tparseInt( row, 10 ) :\n\t\t\trow;\n\t},\n\n\t/**\n\t * Calculate the pixel position from the top of the scrolling container for\n\t * a given row\n\t *  @param {int} iRow Row number to calculate the position of\n\t *  @returns {int} Pixels\n\t */\n\trowToPixels: function ( rowIdx, intParse, virtual )\n\t{\n\t\tvar pixels;\n\t\tvar diff = rowIdx - this.s.baseRowTop;\n\n\t\tif ( virtual ) {\n\t\t\tpixels = this._domain( 'virtualToPhysical', this.s.baseScrollTop );\n\t\t\tpixels += diff * this.s.heights.row;\n\t\t}\n\t\telse {\n\t\t\tpixels = this.s.baseScrollTop;\n\t\t\tpixels += diff * this.s.heights.row;\n\t\t}\n\n\t\treturn intParse || intParse === undefined ?\n\t\t\tparseInt( pixels, 10 ) :\n\t\t\tpixels;\n\t},\n\n\n\t/**\n\t * Calculate the row number that will be found at the given pixel position (y-scroll)\n\t *  @param {int} row Row index to scroll to\n\t *  @param {bool} [animate=true] Animate the transition or not\n\t *  @returns {void}\n\t */\n\tscrollToRow: function ( row, animate )\n\t{\n\t\tvar that = this;\n\t\tvar ani = false;\n\t\tvar px = this.rowToPixels( row );\n\n\t\t// We need to know if the table will redraw or not before doing the\n\t\t// scroll. If it will not redraw, then we need to use the currently\n\t\t// displayed table, and scroll with the physical pixels. Otherwise, we\n\t\t// need to calculate the table's new position from the virtual\n\t\t// transform.\n\t\tvar preRows = ((this.s.displayBuffer-1)/2) * this.s.viewportRows;\n\t\tvar drawRow = row - preRows;\n\t\tif ( drawRow < 0 ) {\n\t\t\tdrawRow = 0;\n\t\t}\n\n\t\tif ( (px > this.s.redrawBottom || px < this.s.redrawTop) && this.s.dt._iDisplayStart !== drawRow ) {\n\t\t\tani = true;\n\t\t\tpx = this._domain( 'virtualToPhysical', row * this.s.heights.row );\n\n\t\t\t// If we need records outside the current draw region, but the new\n\t\t\t// scrolling position is inside that (due to the non-linear nature\n\t\t\t// for larger numbers of records), we need to force position update.\n\t\t\tif ( this.s.redrawTop < px && px < this.s.redrawBottom ) {\n\t\t\t\tthis.s.forceReposition = true;\n\t\t\t\tanimate = false;\n\t\t\t}\n\t\t}\n\n\t\tif ( animate === undefined || animate )\n\t\t{\n\t\t\tthis.s.ani = ani;\n\t\t\t$(this.dom.scroller).animate( {\n\t\t\t\t\"scrollTop\": px\n\t\t\t}, function () {\n\t\t\t\t// This needs to happen after the animation has completed and\n\t\t\t\t// the final scroll event fired\n\t\t\t\tsetTimeout( function () {\n\t\t\t\t\tthat.s.ani = false;\n\t\t\t\t}, 250 );\n\t\t\t} );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$(this.dom.scroller).scrollTop( px );\n\t\t}\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Initialisation for Scroller\n\t *  @returns {void}\n\t *  @private\n\t */\n\tconstruct: function ()\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dtApi;\n\n\t\t/* Sanity check */\n\t\tif ( !this.s.dt.oFeatures.bPaginate ) {\n\t\t\tthis.s.dt.oApi._fnLog( this.s.dt, 0, 'Pagination must be enabled for Scroller' );\n\t\t\treturn;\n\t\t}\n\n\t\t/* Insert a div element that we can use to force the DT scrolling container to\n\t\t * the height that would be required if the whole table was being displayed\n\t\t */\n\t\tthis.dom.force.style.position = \"relative\";\n\t\tthis.dom.force.style.top = \"0px\";\n\t\tthis.dom.force.style.left = \"0px\";\n\t\tthis.dom.force.style.width = \"1px\";\n\n\t\tthis.dom.scroller = $('div.'+this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0];\n\t\tthis.dom.scroller.appendChild( this.dom.force );\n\t\tthis.dom.scroller.style.position = \"relative\";\n\n\t\tthis.dom.table = $('>table', this.dom.scroller)[0];\n\t\tthis.dom.table.style.position = \"absolute\";\n\t\tthis.dom.table.style.top = \"0px\";\n\t\tthis.dom.table.style.left = \"0px\";\n\n\t\t// Add class to 'announce' that we are a Scroller table\n\t\t$(dt.table().container()).addClass('dts DTS');\n\n\t\t// Add a 'loading' indicator\n\t\tif ( this.s.loadingIndicator )\n\t\t{\n\t\t\tthis.dom.loader = $('<div class=\"dataTables_processing dts_loading\">'+this.s.dt.oLanguage.sLoadingRecords+'</div>')\n\t\t\t\t.css('display', 'none');\n\n\t\t\t$(this.dom.scroller.parentNode)\n\t\t\t\t.css('position', 'relative')\n\t\t\t\t.append( this.dom.loader );\n\t\t}\n\n\t\tthis.dom.label.appendTo(this.dom.scroller);\n\n\t\t/* Initial size calculations */\n\t\tif ( this.s.heights.row && this.s.heights.row != 'auto' )\n\t\t{\n\t\t\tthis.s.autoHeight = false;\n\t\t}\n\n\t\t// Scrolling callback to see if a page change is needed\n\t\tthis.s.ingnoreScroll = true;\n\t\t$(this.dom.scroller).on( 'scroll.dt-scroller', function (e) {\n\t\t\tthat._scroll.call( that );\n\t\t} );\n\n\t\t// In iOS we catch the touchstart event in case the user tries to scroll\n\t\t// while the display is already scrolling\n\t\t$(this.dom.scroller).on('touchstart.dt-scroller', function () {\n\t\t\tthat._scroll.call( that );\n\t\t} );\n\n\t\t$(this.dom.scroller)\n\t\t\t.on('mousedown.dt-scroller', function () {\n\t\t\t\tthat.s.mousedown = true;\n\t\t\t})\n\t\t\t.on('mouseup.dt-scroller', function () {\n\t\t\t\tthat.s.labelVisible = false;\n\t\t\t\tthat.s.mousedown = false;\n\t\t\t\tthat.dom.label.css('display', 'none');\n\t\t\t});\n\n\t\t// On resize, update the information element, since the number of rows shown might change\n\t\t$(window).on( 'resize.dt-scroller', function () {\n\t\t\tthat.measure( false );\n\t\t\tthat._info();\n\t\t} );\n\n\t\t// Add a state saving parameter to the DT state saving so we can restore the exact\n\t\t// position of the scrolling.\n\t\tvar initialStateSave = true;\n\t\tvar loadedState = dt.state.loaded();\n\n\t\tdt.on( 'stateSaveParams.scroller', function ( e, settings, data ) {\n\t\t\tif ( initialStateSave && loadedState ) {\n\t\t\t\tdata.scroller = loadedState.scroller;\n\t\t\t\tinitialStateSave = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Need to used the saved position on init\n\t\t\t\tdata.scroller = {\n\t\t\t\t\ttopRow: that.s.topRowFloat,\n\t\t\t\t\tbaseScrollTop: that.s.baseScrollTop,\n\t\t\t\t\tbaseRowTop: that.s.baseRowTop,\n\t\t\t\t\tscrollTop: that.s.lastScrollTop\n\t\t\t\t};\n\t\t\t}\n\t\t} );\n\n\t\tif ( loadedState && loadedState.scroller ) {\n\t\t\tthis.s.topRowFloat = loadedState.scroller.topRow;\n\t\t\tthis.s.baseScrollTop = loadedState.scroller.baseScrollTop;\n\t\t\tthis.s.baseRowTop = loadedState.scroller.baseRowTop;\n\t\t}\n\n\t\tthis.measure( false );\n\t\n\t\tthat.s.stateSaveThrottle = that.s.dt.oApi._fnThrottle( function () {\n\t\t\tthat.s.dtApi.state.save();\n\t\t}, 500 );\n\n\t\tdt.on( 'init.scroller', function () {\n\t\t\tthat.measure( false );\n\n\t\t\t// Setting to `jump` will instruct _draw to calculate the scroll top\n\t\t\t// position\n\t\t\tthat.s.scrollType = 'jump';\n\t\t\tthat._draw();\n\n\t\t\t// Update the scroller when the DataTable is redrawn\n\t\t\tdt.on( 'draw.scroller', function () {\n\t\t\t\tthat._draw();\n\t\t\t});\n\t\t} );\n\n\t\t// Set height before the draw happens, allowing everything else to update\n\t\t// on draw complete without worry for roder.\n\t\tdt.on( 'preDraw.dt.scroller', function () {\n\t\t\tthat._scrollForce();\n\t\t} );\n\n\t\t// Destructor\n\t\tdt.on( 'destroy.scroller', function () {\n\t\t\t$(window).off( 'resize.dt-scroller' );\n\t\t\t$(that.dom.scroller).off('.dt-scroller');\n\t\t\t$(that.s.dt.nTable).off( '.scroller' );\n\n\t\t\t$(that.s.dt.nTableWrapper).removeClass('DTS');\n\t\t\t$('div.DTS_Loading', that.dom.scroller.parentNode).remove();\n\n\t\t\tthat.dom.table.style.position = \"\";\n\t\t\tthat.dom.table.style.top = \"\";\n\t\t\tthat.dom.table.style.left = \"\";\n\t\t} );\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\t/**\n\t * Automatic calculation of table row height. This is just a little tricky here as using\n\t * initialisation DataTables has tale the table out of the document, so we need to create\n\t * a new table and insert it into the document, calculate the row height and then whip the\n\t * table out.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_calcRowHeight: function ()\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar origTable = dt.nTable;\n\t\tvar nTable = origTable.cloneNode( false );\n\t\tvar tbody = $('<tbody/>').appendTo( nTable );\n\t\tvar container = $(\n\t\t\t'<div class=\"'+dt.oClasses.sWrapper+' DTS\">'+\n\t\t\t\t'<div class=\"'+dt.oClasses.sScrollWrapper+'\">'+\n\t\t\t\t\t'<div class=\"'+dt.oClasses.sScrollBody+'\"></div>'+\n\t\t\t\t'</div>'+\n\t\t\t'</div>'\n\t\t);\n\n\t\t// Want 3 rows in the sizing table so :first-child and :last-child\n\t\t// CSS styles don't come into play - take the size of the middle row\n\t\t$('tbody tr:lt(4)', origTable).clone().appendTo( tbody );\n        var rowsCount = $('tr', tbody).length;\n\n        if ( rowsCount === 1 ) {\n            tbody.prepend('<tr><td>&#160;</td></tr>');\n            tbody.append('<tr><td>&#160;</td></tr>');\n\t\t}\n\t\telse {\n            for (; rowsCount < 3; rowsCount++) {\n                tbody.append('<tr><td>&#160;</td></tr>');\n            }\n\t\t}\n\t\n\t\t$('div.'+dt.oClasses.sScrollBody, container).append( nTable );\n\n\t\t// If initialised using `dom`, use the holding element as the insert point\n\t\tvar insertEl = this.s.dt.nHolding || origTable.parentNode;\n\n\t\tif ( ! $(insertEl).is(':visible') ) {\n\t\t\tinsertEl = 'body';\n\t\t}\n\n\t\t// Remove form element links as they might select over others (particularly radio and checkboxes)\n\t\tcontainer.find(\"input\").removeAttr(\"name\");\n\n\t\tcontainer.appendTo( insertEl );\n\t\tthis.s.heights.row = $('tr', tbody).eq(1).outerHeight();\n\n\t\tcontainer.remove();\n\t},\n\n\t/**\n\t * Draw callback function which is fired when the DataTable is redrawn. The main function of\n\t * this method is to position the drawn table correctly the scrolling container for the rows\n\t * that is displays as a result of the scrolling position.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_draw: function ()\n\t{\n\t\tvar\n\t\t\tthat = this,\n\t\t\theights = this.s.heights,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiTableHeight = $(this.s.dt.nTable).height(),\n\t\t\tdisplayStart = this.s.dt._iDisplayStart,\n\t\t\tdisplayLen = this.s.dt._iDisplayLength,\n\t\t\tdisplayEnd = this.s.dt.fnRecordsDisplay();\n\n\t\t// Disable the scroll event listener while we are updating the DOM\n\t\tthis.s.skip = true;\n\n\t\t// If paging is reset\n\t\tif ( (this.s.dt.bSorted || this.s.dt.bFiltered) && displayStart === 0 && !this.s.dt._drawHold ) {\n\t\t\tthis.s.topRowFloat = 0;\n\t\t}\n\n\t\tiScrollTop = this.s.scrollType === 'jump' ?\n\t\t\tthis._domain( 'virtualToPhysical', this.s.topRowFloat * heights.row ) :\n\t\t\tiScrollTop;\n\n\t\t// Store positional information so positional calculations can be based\n\t\t// upon the current table draw position\n\t\tthis.s.baseScrollTop = iScrollTop;\n\t\tthis.s.baseRowTop = this.s.topRowFloat;\n\n\t\t// Position the table in the virtual scroller\n\t\tvar tableTop = iScrollTop - ((this.s.topRowFloat - displayStart) * heights.row);\n\t\tif ( displayStart === 0 ) {\n\t\t\ttableTop = 0;\n\t\t}\n\t\telse if ( displayStart + displayLen >= displayEnd ) {\n\t\t\ttableTop = heights.scroll - iTableHeight;\n\t\t}\n\n\t\tthis.dom.table.style.top = tableTop+'px';\n\n\t\t/* Cache some information for the scroller */\n\t\tthis.s.tableTop = tableTop;\n\t\tthis.s.tableBottom = iTableHeight + this.s.tableTop;\n\n\t\t// Calculate the boundaries for where a redraw will be triggered by the\n\t\t// scroll event listener\n\t\tvar boundaryPx = (iScrollTop - this.s.tableTop) * this.s.boundaryScale;\n\t\tthis.s.redrawTop = iScrollTop - boundaryPx;\n\t\tthis.s.redrawBottom = iScrollTop + boundaryPx > heights.scroll - heights.viewport - heights.row ?\n\t\t\theights.scroll - heights.viewport - heights.row :\n\t\t\tiScrollTop + boundaryPx;\n\n\t\tthis.s.skip = false;\n\n\t\t// Restore the scrolling position that was saved by DataTable's state\n\t\t// saving Note that this is done on the second draw when data is Ajax\n\t\t// sourced, and the first draw when DOM soured\n\t\tif ( this.s.dt.oFeatures.bStateSave && this.s.dt.oLoadedState !== null &&\n\t\t\t typeof this.s.dt.oLoadedState.scroller != 'undefined' )\n\t\t{\n\t\t\t// A quirk of DataTables is that the draw callback will occur on an\n\t\t\t// empty set if Ajax sourced, but not if server-side processing.\n\t\t\tvar ajaxSourced = (this.s.dt.sAjaxSource || that.s.dt.ajax) && ! this.s.dt.oFeatures.bServerSide ?\n\t\t\t\ttrue :\n\t\t\t\tfalse;\n\n\t\t\tif ( ( ajaxSourced && this.s.dt.iDraw == 2) ||\n\t\t\t     (!ajaxSourced && this.s.dt.iDraw == 1) )\n\t\t\t{\n\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t$(that.dom.scroller).scrollTop( that.s.dt.oLoadedState.scroller.scrollTop );\n\n\t\t\t\t\t// In order to prevent layout thrashing we need another\n\t\t\t\t\t// small delay\n\t\t\t\t\tsetTimeout( function () {\n\t\t\t\t\t\tthat.s.ingnoreScroll = false;\n\t\t\t\t\t}, 0 );\n\t\t\t\t}, 0 );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthat.s.ingnoreScroll = false;\n\t\t}\n\n\t\t// Because of the order of the DT callbacks, the info update will\n\t\t// take precedence over the one we want here. So a 'thread' break is\n\t\t// needed.  Only add the thread break if bInfo is set\n\t\tif ( this.s.dt.oFeatures.bInfo ) {\n\t\t\tsetTimeout( function () {\n\t\t\t\tthat._info.call( that );\n\t\t\t}, 0 );\n\t\t}\n\n\t\t$(this.s.dt.nTable).triggerHandler('position.dts.dt', tableTop);\n\n\t\t// Hide the loading indicator\n\t\tif ( this.dom.loader && this.s.loaderVisible ) {\n\t\t\tthis.dom.loader.css( 'display', 'none' );\n\t\t\tthis.s.loaderVisible = false;\n\t\t}\n\t},\n\n\t/**\n\t * Convert from one domain to another. The physical domain is the actual\n\t * pixel count on the screen, while the virtual is if we had browsers which\n\t * had scrolling containers of infinite height (i.e. the absolute value)\n\t *\n\t *  @param {string} dir Domain transform direction, `virtualToPhysical` or\n\t *    `physicalToVirtual` \n\t *  @returns {number} Calculated transform\n\t *  @private\n\t */\n\t_domain: function ( dir, val )\n\t{\n\t\tvar heights = this.s.heights;\n\t\tvar diff;\n\t\tvar magic = 10000; // the point at which the non-linear calculations start to happen\n\n\t\t// If the virtual and physical height match, then we use a linear\n\t\t// transform between the two, allowing the scrollbar to be linear\n\t\tif ( heights.virtual === heights.scroll ) {\n\t\t\treturn val;\n\t\t}\n\n\t\t// In the first 10k pixels and the last 10k pixels, we want the scrolling\n\t\t// to be linear. After that it can be non-linear. It would be unusual for\n\t\t// anyone to mouse wheel through that much.\n\t\tif ( val < magic ) {\n\t\t\treturn val;\n\t\t}\n\t\telse if ( dir === 'virtualToPhysical' && val >= heights.virtual - magic ) {\n\t\t\tdiff = heights.virtual - val;\n\t\t\treturn heights.scroll - diff;\n\t\t}\n\t\telse if ( dir === 'physicalToVirtual' && val >= heights.scroll - magic ) {\n\t\t\tdiff = heights.scroll - val;\n\t\t\treturn heights.virtual - diff;\n\t\t}\n\n\t\t// Otherwise, we want a non-linear scrollbar to take account of the\n\t\t// redrawing regions at the start and end of the table, otherwise these\n\t\t// can stutter badly - on large tables 30px (for example) scroll might\n\t\t// be hundreds of rows, so the table would be redrawing every few px at\n\t\t// the start and end. Use a simple linear eq. to stop this, effectively\n\t\t// causing a kink in the scrolling ratio. It does mean the scrollbar is\n\t\t// non-linear, but with such massive data sets, the scrollbar is going\n\t\t// to be a best guess anyway\n\t\tvar m = (heights.virtual - magic - magic) / (heights.scroll - magic - magic);\n\t\tvar c = magic - (m*magic);\n\n\t\treturn dir === 'virtualToPhysical' ?\n\t\t\t(val-c) / m :\n\t\t\t(m*val) + c;\n\t},\n\n\t/**\n\t * Update any information elements that are controlled by the DataTable based on the scrolling\n\t * viewport and what rows are visible in it. This function basically acts in the same way as\n\t * _fnUpdateInfo in DataTables, and effectively replaces that function.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_info: function ()\n\t{\n\t\tif ( !this.s.dt.oFeatures.bInfo )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvar\n\t\t\tdt = this.s.dt,\n\t\t\tlanguage = dt.oLanguage,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiStart = Math.floor( this.pixelsToRow(iScrollTop, false, this.s.ani)+1 ),\n\t\t\tiMax = dt.fnRecordsTotal(),\n\t\t\tiTotal = dt.fnRecordsDisplay(),\n\t\t\tiPossibleEnd = Math.ceil( this.pixelsToRow(iScrollTop+this.s.heights.viewport, false, this.s.ani) ),\n\t\t\tiEnd = iTotal < iPossibleEnd ? iTotal : iPossibleEnd,\n\t\t\tsStart = dt.fnFormatNumber( iStart ),\n\t\t\tsEnd = dt.fnFormatNumber( iEnd ),\n\t\t\tsMax = dt.fnFormatNumber( iMax ),\n\t\t\tsTotal = dt.fnFormatNumber( iTotal ),\n\t\t\tsOut;\n\n\t\tif ( dt.fnRecordsDisplay() === 0 &&\n\t\t\t   dt.fnRecordsDisplay() == dt.fnRecordsTotal() )\n\t\t{\n\t\t\t/* Empty record set */\n\t\t\tsOut = language.sInfoEmpty+ language.sInfoPostFix;\n\t\t}\n\t\telse if ( dt.fnRecordsDisplay() === 0 )\n\t\t{\n\t\t\t/* Empty record set after filtering */\n\t\t\tsOut = language.sInfoEmpty +' '+\n\t\t\t\tlanguage.sInfoFiltered.replace('_MAX_', sMax)+\n\t\t\t\t\tlanguage.sInfoPostFix;\n\t\t}\n\t\telse if ( dt.fnRecordsDisplay() == dt.fnRecordsTotal() )\n\t\t{\n\t\t\t/* Normal record set */\n\t\t\tsOut = language.sInfo.\n\t\t\t\t\treplace('_START_', sStart).\n\t\t\t\t\treplace('_END_',   sEnd).\n\t\t\t\t\treplace('_MAX_',   sMax).\n\t\t\t\t\treplace('_TOTAL_', sTotal)+\n\t\t\t\tlanguage.sInfoPostFix;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* Record set after filtering */\n\t\t\tsOut = language.sInfo.\n\t\t\t\t\treplace('_START_', sStart).\n\t\t\t\t\treplace('_END_',   sEnd).\n\t\t\t\t\treplace('_MAX_',   sMax).\n\t\t\t\t\treplace('_TOTAL_', sTotal) +' '+\n\t\t\t\tlanguage.sInfoFiltered.replace(\n\t\t\t\t\t'_MAX_',\n\t\t\t\t\tdt.fnFormatNumber(dt.fnRecordsTotal())\n\t\t\t\t)+\n\t\t\t\tlanguage.sInfoPostFix;\n\t\t}\n\n\t\tvar callback = language.fnInfoCallback;\n\t\tif ( callback ) {\n\t\t\tsOut = callback.call( dt.oInstance,\n\t\t\t\tdt, iStart, iEnd, iMax, iTotal, sOut\n\t\t\t);\n\t\t}\n\n\t\tvar n = dt.aanFeatures.i;\n\t\tif ( typeof n != 'undefined' )\n\t\t{\n\t\t\tfor ( var i=0, iLen=n.length ; i<iLen ; i++ )\n\t\t\t{\n\t\t\t\t$(n[i]).html( sOut );\n\t\t\t}\n\t\t}\n\n\t\t// DT doesn't actually (yet) trigger this event, but it will in future\n\t\t$(dt.nTable).triggerHandler( 'info.dt' );\n\t},\n\n\t/**\n\t * Parse CSS height property string as number\n\t *\n\t * An attempt is made to parse the string as a number. Currently supported units are 'px',\n\t * 'vh', and 'rem'. 'em' is partially supported; it works as long as the parent element's\n\t * font size matches the body element. Zero is returned for unrecognized strings.\n\t *  @param {string} cssHeight CSS height property string\n\t *  @returns {number} height\n\t *  @private\n\t */\n\t_parseHeight: function(cssHeight) {\n\t\tvar height;\n\t\tvar matches = /^([+-]?(?:\\d+(?:\\.\\d+)?|\\.\\d+))(px|em|rem|vh)$/.exec(cssHeight);\n\n\t\tif (matches === null) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar value = parseFloat(matches[1]);\n\t\tvar unit = matches[2];\n\n\t\tif ( unit === 'px' ) {\n\t\t\theight = value;\n\t\t}\n\t\telse if ( unit === 'vh' ) {\n\t\t\theight = ( value / 100 ) * $(window).height();\n\t\t}\n\t\telse if ( unit === 'rem' ) {\n\t\t\theight = value * parseFloat($(':root').css('font-size'));\n\t\t}\n\t\telse if ( unit === 'em' ) {\n\t\t\theight = value * parseFloat($('body').css('font-size'));\n\t\t}\n\n\t\treturn height ?\n\t\t\theight :\n\t\t\t0;\n\t},\n\n\t/**\n\t * Scrolling function - fired whenever the scrolling position is changed.\n\t * This method needs to use the stored values to see if the table should be\n\t * redrawn as we are moving towards the end of the information that is\n\t * currently drawn or not. If needed, then it will redraw the table based on\n\t * the new position.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_scroll: function ()\n\t{\n\t\tvar\n\t\t\tthat = this,\n\t\t\theights = this.s.heights,\n\t\t\tiScrollTop = this.dom.scroller.scrollTop,\n\t\t\tiTopRow;\n\n\t\tif ( this.s.skip ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( this.s.ingnoreScroll ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( iScrollTop === this.s.lastScrollTop ) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* If the table has been sorted or filtered, then we use the redraw that\n\t\t * DataTables as done, rather than performing our own\n\t\t */\n\t\tif ( this.s.dt.bFiltered || this.s.dt.bSorted ) {\n\t\t\tthis.s.lastScrollTop = 0;\n\t\t\treturn;\n\t\t}\n\n\t\t/* Update the table's information display for what is now in the viewport */\n\t\tthis._info();\n\n\t\t/* We don't want to state save on every scroll event - that's heavy\n\t\t * handed, so use a timeout to update the state saving only when the\n\t\t * scrolling has finished\n\t\t */\n\t\tclearTimeout( this.s.stateTO );\n\t\tthis.s.stateTO = setTimeout( function () {\n\t\t\tthat.s.dtApi.state.save();\n\t\t}, 250 );\n\n\t\tthis.s.scrollType = Math.abs(iScrollTop - this.s.lastScrollTop) > heights.viewport ?\n\t\t\t'jump' :\n\t\t\t'cont';\n\n\t\tthis.s.topRowFloat = this.s.scrollType === 'cont' ?\n\t\t\tthis.pixelsToRow( iScrollTop, false, false ) :\n\t\t\tthis._domain( 'physicalToVirtual', iScrollTop ) / heights.row;\n\n\t\tif ( this.s.topRowFloat < 0 ) {\n\t\t\tthis.s.topRowFloat = 0;\n\t\t}\n\n\t\t/* Check if the scroll point is outside the trigger boundary which would required\n\t\t * a DataTables redraw\n\t\t */\n\t\tif ( this.s.forceReposition || iScrollTop < this.s.redrawTop || iScrollTop > this.s.redrawBottom ) {\n\t\t\tvar preRows = Math.ceil( ((this.s.displayBuffer-1)/2) * this.s.viewportRows );\n\n\t\t\tiTopRow = parseInt(this.s.topRowFloat, 10) - preRows;\n\t\t\tthis.s.forceReposition = false;\n\n\t\t\tif ( iTopRow <= 0 ) {\n\t\t\t\t/* At the start of the table */\n\t\t\t\tiTopRow = 0;\n\t\t\t}\n\t\t\telse if ( iTopRow + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay() ) {\n\t\t\t\t/* At the end of the table */\n\t\t\t\tiTopRow = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength;\n\t\t\t\tif ( iTopRow < 0 ) {\n\t\t\t\t\tiTopRow = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( iTopRow % 2 !== 0 ) {\n\t\t\t\t// For the row-striping classes (odd/even) we want only to start\n\t\t\t\t// on evens otherwise the stripes will change between draws and\n\t\t\t\t// look rubbish\n\t\t\t\tiTopRow++;\n\t\t\t}\n\n\t\t\t// Store calcuated value, in case the following condition is not met, but so\n\t\t\t// that the draw function will still use it.\n\t\t\tthis.s.targetTop = iTopRow;\n\n\t\t\tif ( iTopRow != this.s.dt._iDisplayStart ) {\n\t\t\t\t/* Cache the new table position for quick lookups */\n\t\t\t\tthis.s.tableTop = $(this.s.dt.nTable).offset().top;\n\t\t\t\tthis.s.tableBottom = $(this.s.dt.nTable).height() + this.s.tableTop;\n\n\t\t\t\tvar draw = function () {\n\t\t\t\t\tthat.s.dt._iDisplayStart = that.s.targetTop;\n\t\t\t\t\tthat.s.dt.oApi._fnDraw( that.s.dt );\n\t\t\t\t};\n\n\t\t\t\t/* Do the DataTables redraw based on the calculated start point - note that when\n\t\t\t\t * using server-side processing we introduce a small delay to not DoS the server...\n\t\t\t\t */\n\t\t\t\tif ( this.s.dt.oFeatures.bServerSide ) {\n\t\t\t\t\tthis.s.forceReposition = true;\n\n\t\t\t\t\tclearTimeout( this.s.drawTO );\n\t\t\t\t\tthis.s.drawTO = setTimeout( draw, this.s.serverWait );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdraw();\n\t\t\t\t}\n\n\t\t\t\tif ( this.dom.loader && ! this.s.loaderVisible ) {\n\t\t\t\t\tthis.dom.loader.css( 'display', 'block' );\n\t\t\t\t\tthis.s.loaderVisible = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.s.topRowFloat = this.pixelsToRow( iScrollTop, false, true );\n\t\t}\n\n\t\tthis.s.lastScrollTop = iScrollTop;\n\t\tthis.s.stateSaveThrottle();\n\n\t\tif ( this.s.scrollType === 'jump' && this.s.mousedown ) {\n\t\t\tthis.s.labelVisible = true;\n\t\t}\n\t\tif (this.s.labelVisible) {\n\t\t\tthis.dom.label\n\t\t\t\t.html( this.s.dt.fnFormatNumber( parseInt( this.s.topRowFloat, 10 )+1 ) )\n\t\t\t\t.css( 'top', iScrollTop + (iScrollTop * heights.labelFactor) )\n\t\t\t\t.css( 'display', 'block' );\n\t\t}\n\t},\n\n\t/**\n\t * Force the scrolling container to have height beyond that of just the\n\t * table that has been drawn so the user can scroll the whole data set.\n\t *\n\t * Note that if the calculated required scrolling height exceeds a maximum\n\t * value (1 million pixels - hard-coded) the forcing element will be set\n\t * only to that maximum value and virtual / physical domain transforms will\n\t * be used to allow Scroller to display tables of any number of records.\n\t *  @returns {void}\n\t *  @private\n\t */\n\t_scrollForce: function ()\n\t{\n\t\tvar heights = this.s.heights;\n\t\tvar max = 1000000;\n\n\t\theights.virtual = heights.row * this.s.dt.fnRecordsDisplay();\n\t\theights.scroll = heights.virtual;\n\n\t\tif ( heights.scroll > max ) {\n\t\t\theights.scroll = max;\n\t\t}\n\n\t\t// Minimum height so there is always a row visible (the 'no rows found'\n\t\t// if reduced to zero filtering)\n\t\tthis.dom.force.style.height = heights.scroll > this.s.heights.row ?\n\t\t\theights.scroll+'px' :\n\t\t\tthis.s.heights.row+'px';\n\t}\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Statics\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n/**\n * Scroller default settings for initialisation\n *  @namespace\n *  @name Scroller.defaults\n *  @static\n */\nScroller.defaults = {\n\t/**\n\t * Scroller uses the boundary scaling factor to decide when to redraw the table - which it\n\t * typically does before you reach the end of the currently loaded data set (in order to\n\t * allow the data to look continuous to a user scrolling through the data). If given as 0\n\t * then the table will be redrawn whenever the viewport is scrolled, while 1 would not\n\t * redraw the table until the currently loaded data has all been shown. You will want\n\t * something in the middle - the default factor of 0.5 is usually suitable.\n\t *  @type     float\n\t *  @default  0.5\n\t *  @static\n\t */\n\tboundaryScale: 0.5,\n\n\t/**\n\t * The display buffer is what Scroller uses to calculate how many rows it should pre-fetch\n\t * for scrolling. Scroller automatically adjusts DataTables' display length to pre-fetch\n\t * rows that will be shown in \"near scrolling\" (i.e. just beyond the current display area).\n\t * The value is based upon the number of rows that can be displayed in the viewport (i.e.\n\t * a value of 1), and will apply the display range to records before before and after the\n\t * current viewport - i.e. a factor of 3 will allow Scroller to pre-fetch 1 viewport's worth\n\t * of rows before the current viewport, the current viewport's rows and 1 viewport's worth\n\t * of rows after the current viewport. Adjusting this value can be useful for ensuring\n\t * smooth scrolling based on your data set.\n\t *  @type     int\n\t *  @default  7\n\t *  @static\n\t */\n\tdisplayBuffer: 9,\n\n\t/**\n\t * Show (or not) the loading element in the background of the table. Note that you should\n\t * include the dataTables.scroller.css file for this to be displayed correctly.\n\t *  @type     boolean\n\t *  @default  false\n\t *  @static\n\t */\n\tloadingIndicator: false,\n\n\t/**\n\t * Scroller will attempt to automatically calculate the height of rows for it's internal\n\t * calculations. However the height that is used can be overridden using this parameter.\n\t *  @type     int|string\n\t *  @default  auto\n\t *  @static\n\t */\n\trowHeight: \"auto\",\n\n\t/**\n\t * When using server-side processing, Scroller will wait a small amount of time to allow\n\t * the scrolling to finish before requesting more data from the server. This prevents\n\t * you from DoSing your own server! The wait time can be configured by this parameter.\n\t *  @type     int\n\t *  @default  200\n\t *  @static\n\t */\n\tserverWait: 200\n};\n\nScroller.oDefaults = Scroller.defaults;\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Constants\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Scroller version\n *  @type      String\n *  @default   See code\n *  @name      Scroller.version\n *  @static\n */\nScroller.version = \"2.0.4\";\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Initialisation\n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n// Attach a listener to the document which listens for DataTables initialisation\n// events so we can automatically initialise\n$(document).on( 'preInit.dt.dtscroller', function (e, settings) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tvar init = settings.oInit.scroller;\n\tvar defaults = DataTable.defaults.scroller;\n\n\tif ( init || defaults ) {\n\t\tvar opts = $.extend( {}, init, defaults );\n\n\t\tif ( init !== false ) {\n\t\t\tnew Scroller( settings, opts  );\n\t\t}\n\t}\n} );\n\n\n// Attach Scroller to DataTables so it can be accessed as an 'extra'\n$.fn.dataTable.Scroller = Scroller;\n$.fn.DataTable.Scroller = Scroller;\n\n\n// DataTables 1.10 API method aliases\nvar Api = $.fn.dataTable.Api;\n\nApi.register( 'scroller()', function () {\n\treturn this;\n} );\n\n// Undocumented and deprecated - is it actually useful at all?\nApi.register( 'scroller().rowToPixels()', function ( rowIdx, intParse, virtual ) {\n\tvar ctx = this.context;\n\n\tif ( ctx.length && ctx[0].oScroller ) {\n\t\treturn ctx[0].oScroller.rowToPixels( rowIdx, intParse, virtual );\n\t}\n\t// undefined\n} );\n\n// Undocumented and deprecated - is it actually useful at all?\nApi.register( 'scroller().pixelsToRow()', function ( pixels, intParse, virtual ) {\n\tvar ctx = this.context;\n\n\tif ( ctx.length && ctx[0].oScroller ) {\n\t\treturn ctx[0].oScroller.pixelsToRow( pixels, intParse, virtual );\n\t}\n\t// undefined\n} );\n\n// `scroller().scrollToRow()` is undocumented and deprecated. Use `scroller.toPosition()\nApi.register( ['scroller().scrollToRow()', 'scroller.toPosition()'], function ( idx, ani ) {\n\tthis.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx.oScroller ) {\n\t\t\tctx.oScroller.scrollToRow( idx, ani );\n\t\t}\n\t} );\n\n\treturn this;\n} );\n\nApi.register( 'row().scrollTo()', function ( ani ) {\n\tvar that = this;\n\n\tthis.iterator( 'row', function ( ctx, rowIdx ) {\n\t\tif ( ctx.oScroller ) {\n\t\t\tvar displayIdx = that\n\t\t\t\t.rows( { order: 'applied', search: 'applied' } )\n\t\t\t\t.indexes()\n\t\t\t\t.indexOf( rowIdx );\n\n\t\t\tctx.oScroller.scrollToRow( displayIdx, ani );\n\t\t}\n\t} );\n\n\treturn this;\n} );\n\nApi.register( 'scroller.measure()', function ( redraw ) {\n\tthis.iterator( 'table', function ( ctx ) {\n\t\tif ( ctx.oScroller ) {\n\t\t\tctx.oScroller.measure( redraw );\n\t\t}\n\t} );\n\n\treturn this;\n} );\n\nApi.register( 'scroller.page()', function() {\n\tvar ctx = this.context;\n\n\tif ( ctx.length && ctx[0].oScroller ) {\n\t\treturn ctx[0].oScroller.pageInfo();\n\t}\n\t// undefined\n} );\n\nreturn Scroller;\n}));\n"]},"metadata":{},"sourceType":"script"}